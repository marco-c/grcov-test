<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - security/sandbox/chromium/base/callback.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">security/sandbox/chromium/base</a> - callback.h<span style="font-size: 80%;"> (source / <a href="callback.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-03-15 12:17:56</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">0</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryLo">0.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : // Copyright (c) 2012 The Chromium Authors. All rights reserved.</a>
<span class="lineNum">       2 </span>            : // Use of this source code is governed by a BSD-style license that can be
<span class="lineNum">       3 </span>            : // found in the LICENSE file.
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : #ifndef BASE_CALLBACK_H_
<span class="lineNum">       6 </span>            : #define BASE_CALLBACK_H_
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : #include &quot;base/callback_forward.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;base/callback_internal.h&quot;
<span class="lineNum">      10 </span>            : #include &quot;base/template_util.h&quot;
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : // NOTE: Header files that do not require the full definition of Callback or
<span class="lineNum">      13 </span>            : // Closure should #include &quot;base/callback_forward.h&quot; instead of this file.
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">      16 </span>            : // Introduction
<span class="lineNum">      17 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">      18 </span>            : //
<span class="lineNum">      19 </span>            : // The templated Callback class is a generalized function object. Together
<span class="lineNum">      20 </span>            : // with the Bind() function in bind.h, they provide a type-safe method for
<span class="lineNum">      21 </span>            : // performing partial application of functions.
<span class="lineNum">      22 </span>            : //
<span class="lineNum">      23 </span>            : // Partial application (or &quot;currying&quot;) is the process of binding a subset of
<span class="lineNum">      24 </span>            : // a function's arguments to produce another function that takes fewer
<span class="lineNum">      25 </span>            : // arguments. This can be used to pass around a unit of delayed execution,
<span class="lineNum">      26 </span>            : // much like lexical closures are used in other languages. For example, it
<span class="lineNum">      27 </span>            : // is used in Chromium code to schedule tasks on different MessageLoops.
<span class="lineNum">      28 </span>            : //
<span class="lineNum">      29 </span>            : // A callback with no unbound input parameters (base::Callback&lt;void()&gt;)
<span class="lineNum">      30 </span>            : // is called a base::Closure. Note that this is NOT the same as what other
<span class="lineNum">      31 </span>            : // languages refer to as a closure -- it does not retain a reference to its
<span class="lineNum">      32 </span>            : // enclosing environment.
<span class="lineNum">      33 </span>            : //
<span class="lineNum">      34 </span>            : // MEMORY MANAGEMENT AND PASSING
<span class="lineNum">      35 </span>            : //
<span class="lineNum">      36 </span>            : // The Callback objects themselves should be passed by const-reference, and
<span class="lineNum">      37 </span>            : // stored by copy. They internally store their state via a refcounted class
<span class="lineNum">      38 </span>            : // and thus do not need to be deleted.
<span class="lineNum">      39 </span>            : //
<span class="lineNum">      40 </span>            : // The reason to pass via a const-reference is to avoid unnecessary
<span class="lineNum">      41 </span>            : // AddRef/Release pairs to the internal state.
<span class="lineNum">      42 </span>            : //
<span class="lineNum">      43 </span>            : //
<span class="lineNum">      44 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">      45 </span>            : // Quick reference for basic stuff
<span class="lineNum">      46 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">      47 </span>            : //
<span class="lineNum">      48 </span>            : // BINDING A BARE FUNCTION
<span class="lineNum">      49 </span>            : //
<span class="lineNum">      50 </span>            : //   int Return5() { return 5; }
<span class="lineNum">      51 </span>            : //   base::Callback&lt;int()&gt; func_cb = base::Bind(&amp;Return5);
<span class="lineNum">      52 </span>            : //   LOG(INFO) &lt;&lt; func_cb.Run();  // Prints 5.
<span class="lineNum">      53 </span>            : //
<span class="lineNum">      54 </span>            : // BINDING A CLASS METHOD
<span class="lineNum">      55 </span>            : //
<span class="lineNum">      56 </span>            : //   The first argument to bind is the member function to call, the second is
<span class="lineNum">      57 </span>            : //   the object on which to call it.
<span class="lineNum">      58 </span>            : //
<span class="lineNum">      59 </span>            : //   class Ref : public base::RefCountedThreadSafe&lt;Ref&gt; {
<span class="lineNum">      60 </span>            : //    public:
<span class="lineNum">      61 </span>            : //     int Foo() { return 3; }
<span class="lineNum">      62 </span>            : //     void PrintBye() { LOG(INFO) &lt;&lt; &quot;bye.&quot;; }
<span class="lineNum">      63 </span>            : //   };
<span class="lineNum">      64 </span>            : //   scoped_refptr&lt;Ref&gt; ref = new Ref();
<span class="lineNum">      65 </span>            : //   base::Callback&lt;void()&gt; ref_cb = base::Bind(&amp;Ref::Foo, ref);
<span class="lineNum">      66 </span>            : //   LOG(INFO) &lt;&lt; ref_cb.Run();  // Prints out 3.
<span class="lineNum">      67 </span>            : //
<span class="lineNum">      68 </span>            : //   By default the object must support RefCounted or you will get a compiler
<span class="lineNum">      69 </span>            : //   error. If you're passing between threads, be sure it's
<span class="lineNum">      70 </span>            : //   RefCountedThreadSafe! See &quot;Advanced binding of member functions&quot; below if
<span class="lineNum">      71 </span>            : //   you don't want to use reference counting.
<span class="lineNum">      72 </span>            : //
<span class="lineNum">      73 </span>            : // RUNNING A CALLBACK
<span class="lineNum">      74 </span>            : //
<span class="lineNum">      75 </span>            : //   Callbacks can be run with their &quot;Run&quot; method, which has the same
<span class="lineNum">      76 </span>            : //   signature as the template argument to the callback.
<span class="lineNum">      77 </span>            : //
<span class="lineNum">      78 </span>            : //   void DoSomething(const base::Callback&lt;void(int, std::string)&gt;&amp; callback) {
<span class="lineNum">      79 </span>            : //     callback.Run(5, &quot;hello&quot;);
<span class="lineNum">      80 </span>            : //   }
<span class="lineNum">      81 </span>            : //
<span class="lineNum">      82 </span>            : //   Callbacks can be run more than once (they don't get deleted or marked when
<span class="lineNum">      83 </span>            : //   run). However, this precludes using base::Passed (see below).
<span class="lineNum">      84 </span>            : //
<span class="lineNum">      85 </span>            : //   void DoSomething(const base::Callback&lt;double(double)&gt;&amp; callback) {
<span class="lineNum">      86 </span>            : //     double myresult = callback.Run(3.14159);
<span class="lineNum">      87 </span>            : //     myresult += callback.Run(2.71828);
<span class="lineNum">      88 </span>            : //   }
<span class="lineNum">      89 </span>            : //
<span class="lineNum">      90 </span>            : // PASSING UNBOUND INPUT PARAMETERS
<span class="lineNum">      91 </span>            : //
<span class="lineNum">      92 </span>            : //   Unbound parameters are specified at the time a callback is Run(). They are
<span class="lineNum">      93 </span>            : //   specified in the Callback template type:
<span class="lineNum">      94 </span>            : //
<span class="lineNum">      95 </span>            : //   void MyFunc(int i, const std::string&amp; str) {}
<span class="lineNum">      96 </span>            : //   base::Callback&lt;void(int, const std::string&amp;)&gt; cb = base::Bind(&amp;MyFunc);
<span class="lineNum">      97 </span>            : //   cb.Run(23, &quot;hello, world&quot;);
<span class="lineNum">      98 </span>            : //
<span class="lineNum">      99 </span>            : // PASSING BOUND INPUT PARAMETERS
<span class="lineNum">     100 </span>            : //
<span class="lineNum">     101 </span>            : //   Bound parameters are specified when you create thee callback as arguments
<span class="lineNum">     102 </span>            : //   to Bind(). They will be passed to the function and the Run()ner of the
<span class="lineNum">     103 </span>            : //   callback doesn't see those values or even know that the function it's
<span class="lineNum">     104 </span>            : //   calling.
<span class="lineNum">     105 </span>            : //
<span class="lineNum">     106 </span>            : //   void MyFunc(int i, const std::string&amp; str) {}
<span class="lineNum">     107 </span>            : //   base::Callback&lt;void()&gt; cb = base::Bind(&amp;MyFunc, 23, &quot;hello world&quot;);
<span class="lineNum">     108 </span>            : //   cb.Run();
<span class="lineNum">     109 </span>            : //
<span class="lineNum">     110 </span>            : //   A callback with no unbound input parameters (base::Callback&lt;void()&gt;)
<span class="lineNum">     111 </span>            : //   is called a base::Closure. So we could have also written:
<span class="lineNum">     112 </span>            : //
<span class="lineNum">     113 </span>            : //   base::Closure cb = base::Bind(&amp;MyFunc, 23, &quot;hello world&quot;);
<span class="lineNum">     114 </span>            : //
<span class="lineNum">     115 </span>            : //   When calling member functions, bound parameters just go after the object
<span class="lineNum">     116 </span>            : //   pointer.
<span class="lineNum">     117 </span>            : //
<span class="lineNum">     118 </span>            : //   base::Closure cb = base::Bind(&amp;MyClass::MyFunc, this, 23, &quot;hello world&quot;);
<span class="lineNum">     119 </span>            : //
<span class="lineNum">     120 </span>            : // PARTIAL BINDING OF PARAMETERS
<span class="lineNum">     121 </span>            : //
<span class="lineNum">     122 </span>            : //   You can specify some parameters when you create the callback, and specify
<span class="lineNum">     123 </span>            : //   the rest when you execute the callback.
<span class="lineNum">     124 </span>            : //
<span class="lineNum">     125 </span>            : //   void MyFunc(int i, const std::string&amp; str) {}
<span class="lineNum">     126 </span>            : //   base::Callback&lt;void(const std::string&amp;)&gt; cb = base::Bind(&amp;MyFunc, 23);
<span class="lineNum">     127 </span>            : //   cb.Run(&quot;hello world&quot;);
<span class="lineNum">     128 </span>            : //
<span class="lineNum">     129 </span>            : //   When calling a function bound parameters are first, followed by unbound
<span class="lineNum">     130 </span>            : //   parameters.
<span class="lineNum">     131 </span>            : //
<span class="lineNum">     132 </span>            : //
<span class="lineNum">     133 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">     134 </span>            : // Quick reference for advanced binding
<span class="lineNum">     135 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">     136 </span>            : //
<span class="lineNum">     137 </span>            : // BINDING A CLASS METHOD WITH WEAK POINTERS
<span class="lineNum">     138 </span>            : //
<span class="lineNum">     139 </span>            : //   base::Bind(&amp;MyClass::Foo, GetWeakPtr());
<span class="lineNum">     140 </span>            : //
<span class="lineNum">     141 </span>            : //   The callback will not be run if the object has already been destroyed.
<span class="lineNum">     142 </span>            : //   DANGER: weak pointers are not threadsafe, so don't use this
<span class="lineNum">     143 </span>            : //   when passing between threads!
<span class="lineNum">     144 </span>            : //
<span class="lineNum">     145 </span>            : // BINDING A CLASS METHOD WITH MANUAL LIFETIME MANAGEMENT
<span class="lineNum">     146 </span>            : //
<span class="lineNum">     147 </span>            : //   base::Bind(&amp;MyClass::Foo, base::Unretained(this));
<span class="lineNum">     148 </span>            : //
<span class="lineNum">     149 </span>            : //   This disables all lifetime management on the object. You're responsible
<span class="lineNum">     150 </span>            : //   for making sure the object is alive at the time of the call. You break it,
<span class="lineNum">     151 </span>            : //   you own it!
<span class="lineNum">     152 </span>            : //
<span class="lineNum">     153 </span>            : // BINDING A CLASS METHOD AND HAVING THE CALLBACK OWN THE CLASS
<span class="lineNum">     154 </span>            : //
<span class="lineNum">     155 </span>            : //   MyClass* myclass = new MyClass;
<span class="lineNum">     156 </span>            : //   base::Bind(&amp;MyClass::Foo, base::Owned(myclass));
<span class="lineNum">     157 </span>            : //
<span class="lineNum">     158 </span>            : //   The object will be deleted when the callback is destroyed, even if it's
<span class="lineNum">     159 </span>            : //   not run (like if you post a task during shutdown). Potentially useful for
<span class="lineNum">     160 </span>            : //   &quot;fire and forget&quot; cases.
<span class="lineNum">     161 </span>            : //
<span class="lineNum">     162 </span>            : // IGNORING RETURN VALUES
<span class="lineNum">     163 </span>            : //
<span class="lineNum">     164 </span>            : //   Sometimes you want to call a function that returns a value in a callback
<span class="lineNum">     165 </span>            : //   that doesn't expect a return value.
<span class="lineNum">     166 </span>            : //
<span class="lineNum">     167 </span>            : //   int DoSomething(int arg) { cout &lt;&lt; arg &lt;&lt; endl; }
<span class="lineNum">     168 </span>            : //   base::Callback&lt;void(int)&gt; cb =
<span class="lineNum">     169 </span>            : //       base::Bind(base::IgnoreResult(&amp;DoSomething));
<span class="lineNum">     170 </span>            : //
<span class="lineNum">     171 </span>            : //
<span class="lineNum">     172 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">     173 </span>            : // Quick reference for binding parameters to Bind()
<span class="lineNum">     174 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">     175 </span>            : //
<span class="lineNum">     176 </span>            : // Bound parameters are specified as arguments to Bind() and are passed to the
<span class="lineNum">     177 </span>            : // function. A callback with no parameters or no unbound parameters is called a
<span class="lineNum">     178 </span>            : // Closure (base::Callback&lt;void()&gt; and base::Closure are the same thing).
<span class="lineNum">     179 </span>            : //
<span class="lineNum">     180 </span>            : // PASSING PARAMETERS OWNED BY THE CALLBACK
<span class="lineNum">     181 </span>            : //
<span class="lineNum">     182 </span>            : //   void Foo(int* arg) { cout &lt;&lt; *arg &lt;&lt; endl; }
<span class="lineNum">     183 </span>            : //   int* pn = new int(1);
<span class="lineNum">     184 </span>            : //   base::Closure foo_callback = base::Bind(&amp;foo, base::Owned(pn));
<span class="lineNum">     185 </span>            : //
<span class="lineNum">     186 </span>            : //   The parameter will be deleted when the callback is destroyed, even if it's
<span class="lineNum">     187 </span>            : //   not run (like if you post a task during shutdown).
<span class="lineNum">     188 </span>            : //
<span class="lineNum">     189 </span>            : // PASSING PARAMETERS AS A scoped_ptr
<span class="lineNum">     190 </span>            : //
<span class="lineNum">     191 </span>            : //   void TakesOwnership(scoped_ptr&lt;Foo&gt; arg) {}
<span class="lineNum">     192 </span>            : //   scoped_ptr&lt;Foo&gt; f(new Foo);
<span class="lineNum">     193 </span>            : //   // f becomes null during the following call.
<span class="lineNum">     194 </span>            : //   base::Closure cb = base::Bind(&amp;TakesOwnership, base::Passed(&amp;f));
<span class="lineNum">     195 </span>            : //
<span class="lineNum">     196 </span>            : //   Ownership of the parameter will be with the callback until the it is run,
<span class="lineNum">     197 </span>            : //   when ownership is passed to the callback function. This means the callback
<span class="lineNum">     198 </span>            : //   can only be run once. If the callback is never run, it will delete the
<span class="lineNum">     199 </span>            : //   object when it's destroyed.
<span class="lineNum">     200 </span>            : //
<span class="lineNum">     201 </span>            : // PASSING PARAMETERS AS A scoped_refptr
<span class="lineNum">     202 </span>            : //
<span class="lineNum">     203 </span>            : //   void TakesOneRef(scoped_refptr&lt;Foo&gt; arg) {}
<span class="lineNum">     204 </span>            : //   scoped_refptr&lt;Foo&gt; f(new Foo)
<span class="lineNum">     205 </span>            : //   base::Closure cb = base::Bind(&amp;TakesOneRef, f);
<span class="lineNum">     206 </span>            : //
<span class="lineNum">     207 </span>            : //   This should &quot;just work.&quot; The closure will take a reference as long as it
<span class="lineNum">     208 </span>            : //   is alive, and another reference will be taken for the called function.
<span class="lineNum">     209 </span>            : //
<span class="lineNum">     210 </span>            : // PASSING PARAMETERS BY REFERENCE
<span class="lineNum">     211 </span>            : //
<span class="lineNum">     212 </span>            : //   Const references are *copied* unless ConstRef is used. Example:
<span class="lineNum">     213 </span>            : //
<span class="lineNum">     214 </span>            : //   void foo(const int&amp; arg) { printf(&quot;%d %p\n&quot;, arg, &amp;arg); }
<span class="lineNum">     215 </span>            : //   int n = 1;
<span class="lineNum">     216 </span>            : //   base::Closure has_copy = base::Bind(&amp;foo, n);
<span class="lineNum">     217 </span>            : //   base::Closure has_ref = base::Bind(&amp;foo, base::ConstRef(n));
<span class="lineNum">     218 </span>            : //   n = 2;
<span class="lineNum">     219 </span>            : //   foo(n);                        // Prints &quot;2 0xaaaaaaaaaaaa&quot;
<span class="lineNum">     220 </span>            : //   has_copy.Run();                // Prints &quot;1 0xbbbbbbbbbbbb&quot;
<span class="lineNum">     221 </span>            : //   has_ref.Run();                 // Prints &quot;2 0xaaaaaaaaaaaa&quot;
<span class="lineNum">     222 </span>            : //
<span class="lineNum">     223 </span>            : //   Normally parameters are copied in the closure. DANGER: ConstRef stores a
<span class="lineNum">     224 </span>            : //   const reference instead, referencing the original parameter. This means
<span class="lineNum">     225 </span>            : //   that you must ensure the object outlives the callback!
<span class="lineNum">     226 </span>            : //
<span class="lineNum">     227 </span>            : //
<span class="lineNum">     228 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">     229 </span>            : // Implementation notes
<span class="lineNum">     230 </span>            : // -----------------------------------------------------------------------------
<span class="lineNum">     231 </span>            : //
<span class="lineNum">     232 </span>            : // WHERE IS THIS DESIGN FROM:
<span class="lineNum">     233 </span>            : //
<span class="lineNum">     234 </span>            : // The design Callback and Bind is heavily influenced by C++'s
<span class="lineNum">     235 </span>            : // tr1::function/tr1::bind, and by the &quot;Google Callback&quot; system used inside
<span class="lineNum">     236 </span>            : // Google.
<span class="lineNum">     237 </span>            : //
<span class="lineNum">     238 </span>            : //
<span class="lineNum">     239 </span>            : // HOW THE IMPLEMENTATION WORKS:
<span class="lineNum">     240 </span>            : //
<span class="lineNum">     241 </span>            : // There are three main components to the system:
<span class="lineNum">     242 </span>            : //   1) The Callback classes.
<span class="lineNum">     243 </span>            : //   2) The Bind() functions.
<span class="lineNum">     244 </span>            : //   3) The arguments wrappers (e.g., Unretained() and ConstRef()).
<span class="lineNum">     245 </span>            : //
<span class="lineNum">     246 </span>            : // The Callback classes represent a generic function pointer. Internally,
<span class="lineNum">     247 </span>            : // it stores a refcounted piece of state that represents the target function
<span class="lineNum">     248 </span>            : // and all its bound parameters.  Each Callback specialization has a templated
<span class="lineNum">     249 </span>            : // constructor that takes an BindState&lt;&gt;*.  In the context of the constructor,
<span class="lineNum">     250 </span>            : // the static type of this BindState&lt;&gt; pointer uniquely identifies the
<span class="lineNum">     251 </span>            : // function it is representing, all its bound parameters, and a Run() method
<span class="lineNum">     252 </span>            : // that is capable of invoking the target.
<span class="lineNum">     253 </span>            : //
<span class="lineNum">     254 </span>            : // Callback's constructor takes the BindState&lt;&gt;* that has the full static type
<span class="lineNum">     255 </span>            : // and erases the target function type as well as the types of the bound
<span class="lineNum">     256 </span>            : // parameters.  It does this by storing a pointer to the specific Run()
<span class="lineNum">     257 </span>            : // function, and upcasting the state of BindState&lt;&gt;* to a
<span class="lineNum">     258 </span>            : // BindStateBase*. This is safe as long as this BindStateBase pointer
<span class="lineNum">     259 </span>            : // is only used with the stored Run() pointer.
<span class="lineNum">     260 </span>            : //
<span class="lineNum">     261 </span>            : // To BindState&lt;&gt; objects are created inside the Bind() functions.
<span class="lineNum">     262 </span>            : // These functions, along with a set of internal templates, are responsible for
<span class="lineNum">     263 </span>            : //
<span class="lineNum">     264 </span>            : //  - Unwrapping the function signature into return type, and parameters
<span class="lineNum">     265 </span>            : //  - Determining the number of parameters that are bound
<span class="lineNum">     266 </span>            : //  - Creating the BindState storing the bound parameters
<span class="lineNum">     267 </span>            : //  - Performing compile-time asserts to avoid error-prone behavior
<span class="lineNum">     268 </span>            : //  - Returning an Callback&lt;&gt; with an arity matching the number of unbound
<span class="lineNum">     269 </span>            : //    parameters and that knows the correct refcounting semantics for the
<span class="lineNum">     270 </span>            : //    target object if we are binding a method.
<span class="lineNum">     271 </span>            : //
<span class="lineNum">     272 </span>            : // The Bind functions do the above using type-inference, and template
<span class="lineNum">     273 </span>            : // specializations.
<span class="lineNum">     274 </span>            : //
<span class="lineNum">     275 </span>            : // By default Bind() will store copies of all bound parameters, and attempt
<span class="lineNum">     276 </span>            : // to refcount a target object if the function being bound is a class method.
<span class="lineNum">     277 </span>            : // These copies are created even if the function takes parameters as const
<span class="lineNum">     278 </span>            : // references. (Binding to non-const references is forbidden, see bind.h.)
<span class="lineNum">     279 </span>            : //
<span class="lineNum">     280 </span>            : // To change this behavior, we introduce a set of argument wrappers
<span class="lineNum">     281 </span>            : // (e.g., Unretained(), and ConstRef()).  These are simple container templates
<span class="lineNum">     282 </span>            : // that are passed by value, and wrap a pointer to argument.  See the
<span class="lineNum">     283 </span>            : // file-level comment in base/bind_helpers.h for more info.
<span class="lineNum">     284 </span>            : //
<span class="lineNum">     285 </span>            : // These types are passed to the Unwrap() functions, and the MaybeRefcount()
<span class="lineNum">     286 </span>            : // functions respectively to modify the behavior of Bind().  The Unwrap()
<span class="lineNum">     287 </span>            : // and MaybeRefcount() functions change behavior by doing partial
<span class="lineNum">     288 </span>            : // specialization based on whether or not a parameter is a wrapper type.
<span class="lineNum">     289 </span>            : //
<span class="lineNum">     290 </span>            : // ConstRef() is similar to tr1::cref.  Unretained() is specific to Chromium.
<span class="lineNum">     291 </span>            : //
<span class="lineNum">     292 </span>            : //
<span class="lineNum">     293 </span>            : // WHY NOT TR1 FUNCTION/BIND?
<span class="lineNum">     294 </span>            : //
<span class="lineNum">     295 </span>            : // Direct use of tr1::function and tr1::bind was considered, but ultimately
<span class="lineNum">     296 </span>            : // rejected because of the number of copy constructors invocations involved
<span class="lineNum">     297 </span>            : // in the binding of arguments during construction, and the forwarding of
<span class="lineNum">     298 </span>            : // arguments during invocation.  These copies will no longer be an issue in
<span class="lineNum">     299 </span>            : // C++0x because C++0x will support rvalue reference allowing for the compiler
<span class="lineNum">     300 </span>            : // to avoid these copies.  However, waiting for C++0x is not an option.
<span class="lineNum">     301 </span>            : //
<span class="lineNum">     302 </span>            : // Measured with valgrind on gcc version 4.4.3 (Ubuntu 4.4.3-4ubuntu5), the
<span class="lineNum">     303 </span>            : // tr1::bind call itself will invoke a non-trivial copy constructor three times
<span class="lineNum">     304 </span>            : // for each bound parameter.  Also, each when passing a tr1::function, each
<span class="lineNum">     305 </span>            : // bound argument will be copied again.
<span class="lineNum">     306 </span>            : //
<span class="lineNum">     307 </span>            : // In addition to the copies taken at binding and invocation, copying a
<span class="lineNum">     308 </span>            : // tr1::function causes a copy to be made of all the bound parameters and
<span class="lineNum">     309 </span>            : // state.
<span class="lineNum">     310 </span>            : //
<span class="lineNum">     311 </span>            : // Furthermore, in Chromium, it is desirable for the Callback to take a
<span class="lineNum">     312 </span>            : // reference on a target object when representing a class method call.  This
<span class="lineNum">     313 </span>            : // is not supported by tr1.
<span class="lineNum">     314 </span>            : //
<span class="lineNum">     315 </span>            : // Lastly, tr1::function and tr1::bind has a more general and flexible API.
<span class="lineNum">     316 </span>            : // This includes things like argument reordering by use of
<span class="lineNum">     317 </span>            : // tr1::bind::placeholder, support for non-const reference parameters, and some
<span class="lineNum">     318 </span>            : // limited amount of subtyping of the tr1::function object (e.g.,
<span class="lineNum">     319 </span>            : // tr1::function&lt;int(int)&gt; is convertible to tr1::function&lt;void(int)&gt;).
<span class="lineNum">     320 </span>            : //
<span class="lineNum">     321 </span>            : // These are not features that are required in Chromium. Some of them, such as
<span class="lineNum">     322 </span>            : // allowing for reference parameters, and subtyping of functions, may actually
<span class="lineNum">     323 </span>            : // become a source of errors. Removing support for these features actually
<span class="lineNum">     324 </span>            : // allows for a simpler implementation, and a terser Currying API.
<span class="lineNum">     325 </span>            : //
<span class="lineNum">     326 </span>            : //
<span class="lineNum">     327 </span>            : // WHY NOT GOOGLE CALLBACKS?
<span class="lineNum">     328 </span>            : //
<span class="lineNum">     329 </span>            : // The Google callback system also does not support refcounting.  Furthermore,
<span class="lineNum">     330 </span>            : // its implementation has a number of strange edge cases with respect to type
<span class="lineNum">     331 </span>            : // conversion of its arguments.  In particular, the argument's constness must
<span class="lineNum">     332 </span>            : // at times match exactly the function signature, or the type-inference might
<span class="lineNum">     333 </span>            : // break.  Given the above, writing a custom solution was easier.
<span class="lineNum">     334 </span>            : //
<span class="lineNum">     335 </span>            : //
<span class="lineNum">     336 </span>            : // MISSING FUNCTIONALITY
<span class="lineNum">     337 </span>            : //  - Invoking the return of Bind.  Bind(&amp;foo).Run() does not work;
<span class="lineNum">     338 </span>            : //  - Binding arrays to functions that take a non-const pointer.
<span class="lineNum">     339 </span>            : //    Example:
<span class="lineNum">     340 </span>            : //      void Foo(const char* ptr);
<span class="lineNum">     341 </span>            : //      void Bar(char* ptr);
<span class="lineNum">     342 </span>            : //      Bind(&amp;Foo, &quot;test&quot;);
<span class="lineNum">     343 </span>            : //      Bind(&amp;Bar, &quot;test&quot;);  // This fails because ptr is not const.
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            : namespace base {
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            : // First, we forward declare the Callback class template. This informs the
<span class="lineNum">     348 </span>            : // compiler that the template only has 1 type parameter which is the function
<span class="lineNum">     349 </span>            : // signature that the Callback is representing.
<span class="lineNum">     350 </span>            : //
<span class="lineNum">     351 </span>            : // After this, create template specializations for 0-7 parameters. Note that
<span class="lineNum">     352 </span>            : // even though the template typelist grows, the specialization still
<span class="lineNum">     353 </span>            : // only has one type: the function signature.
<span class="lineNum">     354 </span>            : //
<span class="lineNum">     355 </span>            : // If you are thinking of forward declaring Callback in your own header file,
<span class="lineNum">     356 </span>            : // please include &quot;base/callback_forward.h&quot; instead.
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            : namespace internal {
<span class="lineNum">     359 </span>            : template &lt;typename Runnable, typename RunType, typename... BoundArgsType&gt;
<span class="lineNum">     360 </span>            : struct BindState;
<span class="lineNum">     361 </span>            : }  // namespace internal
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            : template &lt;typename R, typename... Args&gt;
<span class="lineNum">     364 </span><span class="lineNoCov">          0 : class Callback&lt;R(Args...)&gt; : public internal::CallbackBase {</span>
<span class="lineNum">     365 </span>            :  public:
<span class="lineNum">     366 </span>            :   // MSVC 2013 doesn't support Type Alias of function types.
<span class="lineNum">     367 </span>            :   // Revisit this after we update it to newer version.
<span class="lineNum">     368 </span>            :   typedef R RunType(Args...);
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :   Callback() : CallbackBase(nullptr) { }
<a name="371"><span class="lineNum">     371 </span>            : </a>
<span class="lineNum">     372 </span>            :   template &lt;typename Runnable, typename BindRunType, typename... BoundArgsType&gt;
<span class="lineNum">     373 </span><span class="lineNoCov">          0 :   explicit Callback(</span>
<span class="lineNum">     374 </span>            :       internal::BindState&lt;Runnable, BindRunType, BoundArgsType...&gt;* bind_state)
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :       : CallbackBase(bind_state) {</span>
<span class="lineNum">     376 </span>            :     // Force the assignment to a local variable of PolymorphicInvoke
<span class="lineNum">     377 </span>            :     // so the compiler will typecheck that the passed in Run() method has
<span class="lineNum">     378 </span>            :     // the correct type.
<span class="lineNum">     379 </span>            :     PolymorphicInvoke invoke_func =
<span class="lineNum">     380 </span>            :         &amp;internal::BindState&lt;Runnable, BindRunType, BoundArgsType...&gt;
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :             ::InvokerType::Run;</span>
<span class="lineNum">     382 </span><span class="lineNoCov">          0 :     polymorphic_invoke_ = reinterpret_cast&lt;InvokeFuncStorage&gt;(invoke_func);</span>
<span class="lineNum">     383 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            :   bool Equals(const Callback&amp; other) const {
<span class="lineNum">     386 </span>            :     return CallbackBase::Equals(other);
<a name="387"><span class="lineNum">     387 </span>            :   }</a>
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :   R Run(typename internal::CallbackParamTraits&lt;Args&gt;::ForwardType... args)</span>
<span class="lineNum">     390 </span>            :       const {
<span class="lineNum">     391 </span>            :     PolymorphicInvoke f =
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :         reinterpret_cast&lt;PolymorphicInvoke&gt;(polymorphic_invoke_);</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span><span class="lineNoCov">          0 :     return f(bind_state_.get(), internal::CallbackForward(args)...);</span>
<span class="lineNum">     395 </span>            :   }
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            :  private:
<span class="lineNum">     398 </span>            :   using PolymorphicInvoke =
<span class="lineNum">     399 </span>            :       R(*)(internal::BindStateBase*,
<span class="lineNum">     400 </span>            :            typename internal::CallbackParamTraits&lt;Args&gt;::ForwardType...);
<span class="lineNum">     401 </span>            : };
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            : }  // namespace base
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            : #endif  // BASE_CALLBACK_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13-2-g25f5d38</a></td></tr>
  </table>
  <br>

</body>
</html>
