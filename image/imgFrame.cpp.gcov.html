<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - output.info - image/imgFrame.cpp</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">image</a> - imgFrame.cpp<span style="font-size: 80%;"> (source / <a href="imgFrame.cpp.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">output.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">269</td>
            <td class="headerCovTableEntry">349</td>
            <td class="headerCovTableEntryMed">77.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2017-03-15 21:34:37</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">42</td>
            <td class="headerCovTableEntry">46</td>
            <td class="headerCovTableEntryHi">91.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */</a>
<span class="lineNum">       2 </span>            : /* vim: set ts=2 et sw=2 tw=80: */
<span class="lineNum">       3 </span>            : /* This Source Code Form is subject to the terms of the Mozilla Public
<span class="lineNum">       4 </span>            :  * License, v. 2.0. If a copy of the MPL was not distributed with this
<span class="lineNum">       5 </span>            :  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : #include &quot;imgFrame.h&quot;
<span class="lineNum">       8 </span>            : #include &quot;ImageRegion.h&quot;
<span class="lineNum">       9 </span>            : #include &quot;ShutdownTracker.h&quot;
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : #include &quot;prenv.h&quot;
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : #include &quot;gfx2DGlue.h&quot;
<span class="lineNum">      14 </span>            : #include &quot;gfxPlatform.h&quot;
<span class="lineNum">      15 </span>            : #include &quot;gfxPrefs.h&quot;
<span class="lineNum">      16 </span>            : #include &quot;gfxUtils.h&quot;
<span class="lineNum">      17 </span>            : #include &quot;gfxAlphaRecovery.h&quot;
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : #include &quot;GeckoProfiler.h&quot;
<span class="lineNum">      20 </span>            : #include &quot;MainThreadUtils.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;mozilla/CheckedInt.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;mozilla/gfx/Tools.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;mozilla/layers/SourceSurfaceSharedData.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;mozilla/layers/SourceSurfaceVolatileData.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;mozilla/Likely.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;mozilla/MemoryReporting.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;nsMargin.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;nsThreadUtils.h&quot;
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : 
<span class="lineNum">      31 </span>            : namespace mozilla {
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            : using namespace gfx;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : namespace image {
<a name="36"><span class="lineNum">      36 </span>            : </a>
<span class="lineNum">      37 </span>            : static void
<span class="lineNum">      38 </span><span class="lineCov">          1 : ScopedMapRelease(void* aMap)</span>
<span class="lineNum">      39 </span>            : {
<span class="lineNum">      40 </span><span class="lineCov">          1 :   delete static_cast&lt;DataSourceSurface::ScopedMap*&gt;(aMap);</span>
<span class="lineNum">      41 </span><span class="lineCov">          1 : }</span>
<a name="42"><span class="lineNum">      42 </span>            : </a>
<span class="lineNum">      43 </span>            : static int32_t
<span class="lineNum">      44 </span><span class="lineCov">          1 : VolatileSurfaceStride(const IntSize&amp; size, SurfaceFormat format)</span>
<span class="lineNum">      45 </span>            : {
<span class="lineNum">      46 </span>            :   // Stride must be a multiple of four or cairo will complain.
<span class="lineNum">      47 </span><span class="lineCov">          1 :   return (size.width * BytesPerPixel(format) + 0x3) &amp; ~0x3;</span>
<span class="lineNum">      48 </span>            : }
<a name="49"><span class="lineNum">      49 </span>            : </a>
<span class="lineNum">      50 </span>            : static already_AddRefed&lt;DataSourceSurface&gt;
<span class="lineNum">      51 </span><span class="lineCov">          1 : CreateLockedSurface(DataSourceSurface *aSurface,</span>
<span class="lineNum">      52 </span>            :                     const IntSize&amp; size,
<span class="lineNum">      53 </span>            :                     SurfaceFormat format)
<span class="lineNum">      54 </span>            : {
<span class="lineNum">      55 </span>            :   // Shared memory is never released until the surface itself is released
<span class="lineNum">      56 </span><span class="lineCov">          1 :   if (aSurface-&gt;GetType() == SurfaceType::DATA_SHARED) {</span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :     RefPtr&lt;DataSourceSurface&gt; surf(aSurface);</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :     return surf.forget();</span>
<span class="lineNum">      59 </span>            :   }
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            :   DataSourceSurface::ScopedMap* smap =
<span class="lineNum">      62 </span><span class="lineCov">          1 :     new DataSourceSurface::ScopedMap(aSurface, DataSourceSurface::READ_WRITE);</span>
<span class="lineNum">      63 </span><span class="lineCov">          1 :   if (smap-&gt;IsMapped()) {</span>
<span class="lineNum">      64 </span>            :     // The ScopedMap is held by this DataSourceSurface.
<span class="lineNum">      65 </span>            :     RefPtr&lt;DataSourceSurface&gt; surf =
<span class="lineNum">      66 </span>            :       Factory::CreateWrappingDataSourceSurface(smap-&gt;GetData(),
<span class="lineNum">      67 </span><span class="lineCov">          1 :                                                aSurface-&gt;Stride(),</span>
<span class="lineNum">      68 </span>            :                                                size,
<span class="lineNum">      69 </span>            :                                                format,
<span class="lineNum">      70 </span>            :                                                &amp;ScopedMapRelease,
<span class="lineNum">      71 </span><span class="lineCov">          1 :                                                static_cast&lt;void*&gt;(smap));</span>
<span class="lineNum">      72 </span><span class="lineCov">          1 :     if (surf) {</span>
<span class="lineNum">      73 </span><span class="lineCov">          1 :       return surf.forget();</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">      75 </span>            :   }
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span><span class="lineNoCov">          0 :   delete smap;</span>
<span class="lineNum">      78 </span><span class="lineNoCov">          0 :   return nullptr;</span>
<span class="lineNum">      79 </span>            : }
<a name="80"><span class="lineNum">      80 </span>            : </a>
<span class="lineNum">      81 </span>            : static already_AddRefed&lt;DataSourceSurface&gt;
<span class="lineNum">      82 </span><span class="lineCov">          1 : AllocateBufferForImage(const IntSize&amp; size,</span>
<span class="lineNum">      83 </span>            :                        SurfaceFormat format,
<span class="lineNum">      84 </span>            :                        bool aIsAnimated = false)
<span class="lineNum">      85 </span>            : {
<span class="lineNum">      86 </span><span class="lineCov">          1 :   int32_t stride = VolatileSurfaceStride(size, format);</span>
<span class="lineNum">      87 </span><span class="lineCov">          1 :   if (!aIsAnimated &amp;&amp; gfxPrefs::ImageMemShared()) {</span>
<span class="lineNum">      88 </span><span class="lineNoCov">          0 :     RefPtr&lt;SourceSurfaceSharedData&gt; newSurf = new SourceSurfaceSharedData();</span>
<span class="lineNum">      89 </span><span class="lineNoCov">          0 :     if (newSurf-&gt;Init(size, stride, format)) {</span>
<span class="lineNum">      90 </span>            :       return newSurf.forget();
<span class="lineNum">      91 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">      92 </span>            :   } else {
<span class="lineNum">      93 </span><span class="lineCov">          1 :     RefPtr&lt;SourceSurfaceVolatileData&gt; newSurf= new SourceSurfaceVolatileData();</span>
<span class="lineNum">      94 </span><span class="lineCov">          1 :     if (newSurf-&gt;Init(size, stride, format)) {</span>
<span class="lineNum">      95 </span>            :       return newSurf.forget();
<span class="lineNum">      96 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">      97 </span>            :   }
<span class="lineNum">      98 </span><span class="lineNoCov">          0 :   return nullptr;</span>
<span class="lineNum">      99 </span>            : }
<a name="100"><span class="lineNum">     100 </span>            : </a>
<span class="lineNum">     101 </span>            : static bool
<span class="lineNum">     102 </span><span class="lineCov">          1 : ClearSurface(DataSourceSurface* aSurface, const IntSize&amp; aSize, SurfaceFormat aFormat)</span>
<span class="lineNum">     103 </span>            : {
<span class="lineNum">     104 </span><span class="lineCov">          1 :   int32_t stride = aSurface-&gt;Stride();</span>
<span class="lineNum">     105 </span><span class="lineCov">          1 :   uint8_t* data = aSurface-&gt;GetData();</span>
<span class="lineNum">     106 </span>            :   MOZ_ASSERT(data);
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span><span class="lineCov">          1 :   if (aFormat == SurfaceFormat::B8G8R8X8) {</span>
<span class="lineNum">     109 </span>            :     // Skia doesn't support RGBX surfaces, so ensure the alpha value is set
<span class="lineNum">     110 </span>            :     // to opaque white. While it would be nice to only do this for Skia,
<span class="lineNum">     111 </span>            :     // imgFrame can run off main thread and past shutdown where
<span class="lineNum">     112 </span>            :     // we might not have gfxPlatform, so just memset everytime instead.
<span class="lineNum">     113 </span><span class="lineCov">          1 :     memset(data, 0xFF, stride * aSize.height);</span>
<span class="lineNum">     114 </span><span class="lineCov">          1 :   } else if (aSurface-&gt;OnHeap()) {</span>
<span class="lineNum">     115 </span>            :     // We only need to memset it if the buffer was allocated on the heap.
<span class="lineNum">     116 </span>            :     // Otherwise, it's allocated via mmap and refers to a zeroed page and will
<span class="lineNum">     117 </span>            :     // be COW once it's written to.
<span class="lineNum">     118 </span><span class="lineCov">          1 :     memset(data, 0, stride * aSize.height);</span>
<span class="lineNum">     119 </span>            :   }
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span><span class="lineCov">          1 :   return true;</span>
<span class="lineNum">     122 </span>            : }
<a name="123"><span class="lineNum">     123 </span>            : </a>
<span class="lineNum">     124 </span>            : void
<span class="lineNum">     125 </span><span class="lineCov">          1 : MarkSurfaceShared(SourceSurface* aSurface)</span>
<span class="lineNum">     126 </span>            : {
<span class="lineNum">     127 </span>            :   // Depending on what requested the image decoding, the buffer may or may not
<span class="lineNum">     128 </span>            :   // end up being shared with another process (e.g. put in a painted layer,
<span class="lineNum">     129 </span>            :   // used inside a canvas). If not shared, we should ensure are not keeping the
<span class="lineNum">     130 </span>            :   // handle only because we have yet to share it.
<span class="lineNum">     131 </span><span class="lineCov">          1 :   if (aSurface &amp;&amp; aSurface-&gt;GetType() == SurfaceType::DATA_SHARED) {</span>
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :     auto sharedSurface = static_cast&lt;SourceSurfaceSharedData*&gt;(aSurface);</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     sharedSurface-&gt;FinishedSharing();</span>
<span class="lineNum">     134 </span>            :   }
<span class="lineNum">     135 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     136 </span>            : 
<a name="137"><span class="lineNum">     137 </span>            : // Returns true if an image of aWidth x aHeight is allowed and legal.</a>
<span class="lineNum">     138 </span>            : static bool
<span class="lineNum">     139 </span><span class="lineCov">          1 : AllowedImageSize(int32_t aWidth, int32_t aHeight)</span>
<span class="lineNum">     140 </span>            : {
<span class="lineNum">     141 </span>            :   // reject over-wide or over-tall images
<span class="lineNum">     142 </span><span class="lineCov">          1 :   const int32_t k64KLimit = 0x0000FFFF;</span>
<span class="lineNum">     143 </span><span class="lineCov">          1 :   if (MOZ_UNLIKELY(aWidth &gt; k64KLimit || aHeight &gt; k64KLimit )) {</span>
<span class="lineNum">     144 </span>            :     NS_WARNING(&quot;image too big&quot;);
<span class="lineNum">     145 </span>            :     return false;
<span class="lineNum">     146 </span>            :   }
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :   // protect against invalid sizes
<span class="lineNum">     149 </span><span class="lineCov">          1 :   if (MOZ_UNLIKELY(aHeight &lt;= 0 || aWidth &lt;= 0)) {</span>
<span class="lineNum">     150 </span>            :     return false;
<span class="lineNum">     151 </span>            :   }
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            :   // check to make sure we don't overflow a 32-bit
<span class="lineNum">     154 </span><span class="lineCov">          1 :   CheckedInt32 requiredBytes = CheckedInt32(aWidth) * CheckedInt32(aHeight) * 4;</span>
<span class="lineNum">     155 </span><span class="lineCov">          1 :   if (MOZ_UNLIKELY(!requiredBytes.isValid())) {</span>
<span class="lineNum">     156 </span>            :     NS_WARNING(&quot;width or height too large&quot;);
<span class="lineNum">     157 </span>            :     return false;
<span class="lineNum">     158 </span>            :   }
<span class="lineNum">     159 </span>            : #if defined(XP_MACOSX)
<span class="lineNum">     160 </span>            :   // CoreGraphics is limited to images &lt; 32K in *height*, so clamp all surfaces
<span class="lineNum">     161 </span>            :   // on the Mac to that height
<span class="lineNum">     162 </span>            :   if (MOZ_UNLIKELY(aHeight &gt; SHRT_MAX)) {
<span class="lineNum">     163 </span>            :     NS_WARNING(&quot;image too big&quot;);
<span class="lineNum">     164 </span>            :     return false;
<span class="lineNum">     165 </span>            :   }
<span class="lineNum">     166 </span>            : #endif
<span class="lineNum">     167 </span><span class="lineCov">          1 :   return true;</span>
<a name="168"><span class="lineNum">     168 </span>            : }</a>
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineCov">          1 : static bool AllowedImageAndFrameDimensions(const nsIntSize&amp; aImageSize,</span>
<span class="lineNum">     171 </span>            :                                            const nsIntRect&amp; aFrameRect)
<span class="lineNum">     172 </span>            : {
<span class="lineNum">     173 </span><span class="lineCov">          1 :   if (!AllowedImageSize(aImageSize.width, aImageSize.height)) {</span>
<span class="lineNum">     174 </span>            :     return false;
<span class="lineNum">     175 </span>            :   }
<span class="lineNum">     176 </span><span class="lineCov">          1 :   if (!AllowedImageSize(aFrameRect.width, aFrameRect.height)) {</span>
<span class="lineNum">     177 </span>            :     return false;
<span class="lineNum">     178 </span>            :   }
<span class="lineNum">     179 </span><span class="lineCov">          1 :   nsIntRect imageRect(0, 0, aImageSize.width, aImageSize.height);</span>
<span class="lineNum">     180 </span>            :   if (!imageRect.Contains(aFrameRect)) {
<span class="lineNum">     181 </span>            :     NS_WARNING(&quot;Animated image frame does not fit inside bounds of image&quot;);
<span class="lineNum">     182 </span>            :   }
<span class="lineNum">     183 </span><span class="lineCov">          1 :   return true;</span>
<a name="184"><span class="lineNum">     184 </span>            : }</a>
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span><span class="lineCov">          1 : imgFrame::imgFrame()</span>
<span class="lineNum">     187 </span>            :   : mMonitor(&quot;imgFrame&quot;)
<span class="lineNum">     188 </span>            :   , mDecoded(0, 0, 0, 0)
<span class="lineNum">     189 </span>            :   , mLockCount(0)
<span class="lineNum">     190 </span>            :   , mTimeout(FrameTimeout::FromRawMilliseconds(100))
<span class="lineNum">     191 </span>            :   , mDisposalMethod(DisposalMethod::NOT_SPECIFIED)
<span class="lineNum">     192 </span>            :   , mBlendMethod(BlendMethod::OVER)
<span class="lineNum">     193 </span>            :   , mAborted(false)
<span class="lineNum">     194 </span>            :   , mFinished(false)
<span class="lineNum">     195 </span>            :   , mOptimizable(false)
<span class="lineNum">     196 </span>            :   , mPalettedImageData(nullptr)
<span class="lineNum">     197 </span>            :   , mPaletteDepth(0)
<span class="lineNum">     198 </span>            :   , mNonPremult(false)
<span class="lineNum">     199 </span><span class="lineCov">          1 :   , mCompositingFailed(false)</span>
<span class="lineNum">     200 </span>            : {
<a name="201"><span class="lineNum">     201 </span><span class="lineCov">          1 : }</span></a>
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span><span class="lineCov">          1 : imgFrame::~imgFrame()</span>
<span class="lineNum">     204 </span>            : {
<span class="lineNum">     205 </span>            : #ifdef DEBUG
<span class="lineNum">     206 </span>            :   MonitorAutoLock lock(mMonitor);
<span class="lineNum">     207 </span>            :   MOZ_ASSERT(mAborted || AreAllPixelsWritten());
<span class="lineNum">     208 </span>            :   MOZ_ASSERT(mAborted || mFinished);
<span class="lineNum">     209 </span>            : #endif
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span><span class="lineCov">          1 :   free(mPalettedImageData);</span>
<span class="lineNum">     212 </span><span class="lineCov">          1 :   mPalettedImageData = nullptr;</span>
<span class="lineNum">     213 </span><span class="lineCov">          1 : }</span>
<a name="214"><span class="lineNum">     214 </span>            : </a>
<span class="lineNum">     215 </span>            : nsresult
<span class="lineNum">     216 </span><span class="lineCov">          1 : imgFrame::InitForDecoder(const nsIntSize&amp; aImageSize,</span>
<span class="lineNum">     217 </span>            :                          const nsIntRect&amp; aRect,
<span class="lineNum">     218 </span>            :                          SurfaceFormat aFormat,
<span class="lineNum">     219 </span>            :                          uint8_t aPaletteDepth /* = 0 */,
<span class="lineNum">     220 </span>            :                          bool aNonPremult /* = false */,
<span class="lineNum">     221 </span>            :                          bool aIsAnimated /* = false */)
<span class="lineNum">     222 </span>            : {
<span class="lineNum">     223 </span>            :   // Assert for properties that should be verified by decoders,
<span class="lineNum">     224 </span>            :   // warn for properties related to bad content.
<span class="lineNum">     225 </span><span class="lineCov">          1 :   if (!AllowedImageAndFrameDimensions(aImageSize, aRect)) {</span>
<span class="lineNum">     226 </span>            :     NS_WARNING(&quot;Should have legal image size&quot;);
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :     mAborted = true;</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :     return NS_ERROR_FAILURE;</span>
<span class="lineNum">     229 </span>            :   }
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineCov">          1 :   mImageSize = aImageSize;</span>
<span class="lineNum">     232 </span><span class="lineCov">          1 :   mFrameRect = aRect;</span>
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            :   // We only allow a non-trivial frame rect (i.e., a frame rect that doesn't
<span class="lineNum">     235 </span>            :   // cover the entire image) for paletted animation frames. We never draw those
<span class="lineNum">     236 </span>            :   // frames directly; we just use FrameAnimator to composite them and produce a
<span class="lineNum">     237 </span>            :   // BGRA surface that we actually draw. We enforce this here to make sure that
<span class="lineNum">     238 </span>            :   // imgFrame::Draw(), which is responsible for drawing all other kinds of
<span class="lineNum">     239 </span>            :   // frames, never has to deal with a non-trivial frame rect.
<span class="lineNum">     240 </span><span class="lineCov">          1 :   if (aPaletteDepth == 0 &amp;&amp;</span>
<span class="lineNum">     241 </span><span class="lineCov">          1 :       !mFrameRect.IsEqualEdges(IntRect(IntPoint(), mImageSize))) {</span>
<span class="lineNum">     242 </span>            :     MOZ_ASSERT_UNREACHABLE(&quot;Creating a non-paletted imgFrame with a &quot;
<span class="lineNum">     243 </span>            :                            &quot;non-trivial frame rect&quot;);
<span class="lineNum">     244 </span>            :     return NS_ERROR_FAILURE;
<span class="lineNum">     245 </span>            :   }
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span><span class="lineCov">          1 :   mFormat = aFormat;</span>
<span class="lineNum">     248 </span><span class="lineCov">          1 :   mPaletteDepth = aPaletteDepth;</span>
<span class="lineNum">     249 </span><span class="lineCov">          1 :   mNonPremult = aNonPremult;</span>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineCov">          1 :   if (aPaletteDepth != 0) {</span>
<span class="lineNum">     252 </span>            :     // We're creating for a paletted image.
<span class="lineNum">     253 </span><span class="lineCov">          1 :     if (aPaletteDepth &gt; 8) {</span>
<span class="lineNum">     254 </span>            :       NS_WARNING(&quot;Should have legal palette depth&quot;);
<span class="lineNum">     255 </span>            :       NS_ERROR(&quot;This Depth is not supported&quot;);
<span class="lineNum">     256 </span><span class="lineNoCov">          0 :       mAborted = true;</span>
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :       return NS_ERROR_FAILURE;</span>
<span class="lineNum">     258 </span>            :     }
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            :     // Use the fallible allocator here. Paletted images always use 1 byte per
<span class="lineNum">     261 </span>            :     // pixel, so calculating the amount of memory we need is straightforward.
<span class="lineNum">     262 </span><span class="lineCov">          1 :     size_t dataSize = PaletteDataLength() + mFrameRect.Area();</span>
<span class="lineNum">     263 </span><span class="lineCov">          1 :     mPalettedImageData = static_cast&lt;uint8_t*&gt;(calloc(dataSize, sizeof(uint8_t)));</span>
<span class="lineNum">     264 </span>            :     if (!mPalettedImageData) {
<span class="lineNum">     265 </span>            :       NS_WARNING(&quot;Call to calloc for paletted image data should succeed&quot;);
<span class="lineNum">     266 </span>            :     }
<span class="lineNum">     267 </span><span class="lineCov">          1 :     NS_ENSURE_TRUE(mPalettedImageData, NS_ERROR_OUT_OF_MEMORY);</span>
<span class="lineNum">     268 </span>            :   } else {
<span class="lineNum">     269 </span>            :     MOZ_ASSERT(!mLockedSurface, &quot;Called imgFrame::InitForDecoder() twice?&quot;);
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span><span class="lineCov">          1 :     mRawSurface = AllocateBufferForImage(mFrameRect.Size(), mFormat, aIsAnimated);</span>
<span class="lineNum">     272 </span><span class="lineCov">          1 :     if (!mRawSurface) {</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :       mAborted = true;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :       return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">     275 </span>            :     }
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineCov">          1 :     mLockedSurface = CreateLockedSurface(mRawSurface, mFrameRect.Size(), mFormat);</span>
<span class="lineNum">     278 </span><span class="lineCov">          1 :     if (!mLockedSurface) {</span>
<span class="lineNum">     279 </span>            :       NS_WARNING(&quot;Failed to create LockedSurface&quot;);
<span class="lineNum">     280 </span><span class="lineNoCov">          0 :       mAborted = true;</span>
<span class="lineNum">     281 </span><span class="lineNoCov">          0 :       return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">     282 </span>            :     }
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span><span class="lineCov">          1 :     if (!ClearSurface(mRawSurface, mFrameRect.Size(), mFormat)) {</span>
<span class="lineNum">     285 </span>            :       NS_WARNING(&quot;Could not clear allocated buffer&quot;);
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :       mAborted = true;</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :       return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">     288 </span>            :     }
<span class="lineNum">     289 </span>            :   }
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            :   return NS_OK;
<span class="lineNum">     292 </span>            : }
<a name="293"><span class="lineNum">     293 </span>            : </a>
<span class="lineNum">     294 </span>            : nsresult
<span class="lineNum">     295 </span><span class="lineCov">          1 : imgFrame::InitWithDrawable(gfxDrawable* aDrawable,</span>
<span class="lineNum">     296 </span>            :                            const nsIntSize&amp; aSize,
<span class="lineNum">     297 </span>            :                            const SurfaceFormat aFormat,
<span class="lineNum">     298 </span>            :                            SamplingFilter aSamplingFilter,
<span class="lineNum">     299 </span>            :                            uint32_t aImageFlags,
<span class="lineNum">     300 </span>            :                            gfx::BackendType aBackend)
<span class="lineNum">     301 </span>            : {
<span class="lineNum">     302 </span>            :   // Assert for properties that should be verified by decoders,
<span class="lineNum">     303 </span>            :   // warn for properties related to bad content.
<span class="lineNum">     304 </span><span class="lineCov">          1 :   if (!AllowedImageSize(aSize.width, aSize.height)) {</span>
<span class="lineNum">     305 </span>            :     NS_WARNING(&quot;Should have legal image size&quot;);
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :     mAborted = true;</span>
<span class="lineNum">     307 </span><span class="lineNoCov">          0 :     return NS_ERROR_FAILURE;</span>
<span class="lineNum">     308 </span>            :   }
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span><span class="lineCov">          1 :   mImageSize = aSize;</span>
<span class="lineNum">     311 </span><span class="lineCov">          1 :   mFrameRect = IntRect(IntPoint(0, 0), aSize);</span>
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineCov">          1 :   mFormat = aFormat;</span>
<span class="lineNum">     314 </span><span class="lineCov">          1 :   mPaletteDepth = 0;</span>
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            :   RefPtr&lt;DrawTarget&gt; target;
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            :   bool canUseDataSurface =
<span class="lineNum">     319 </span><span class="lineCov">          1 :     gfxPlatform::GetPlatform()-&gt;CanRenderContentToDataSurface();</span>
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span><span class="lineCov">          1 :   if (canUseDataSurface) {</span>
<span class="lineNum">     322 </span>            :     // It's safe to use data surfaces for content on this platform, so we can
<span class="lineNum">     323 </span>            :     // get away with using volatile buffers.
<span class="lineNum">     324 </span>            :     MOZ_ASSERT(!mLockedSurface, &quot;Called imgFrame::InitWithDrawable() twice?&quot;);
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :     mRawSurface = AllocateBufferForImage(mFrameRect.Size(), mFormat);</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :     if (!mRawSurface) {</span>
<span class="lineNum">     328 </span><span class="lineNoCov">          0 :       mAborted = true;</span>
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :       return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">     330 </span>            :     }
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span><span class="lineNoCov">          0 :     mLockedSurface = CreateLockedSurface(mRawSurface, mFrameRect.Size(), mFormat);</span>
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :     if (!mLockedSurface) {</span>
<span class="lineNum">     334 </span>            :       NS_WARNING(&quot;Failed to create LockedSurface&quot;);
<span class="lineNum">     335 </span><span class="lineNoCov">          0 :       mAborted = true;</span>
<span class="lineNum">     336 </span><span class="lineNoCov">          0 :       return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">     337 </span>            :     }
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :     if (!ClearSurface(mRawSurface, mFrameRect.Size(), mFormat)) {</span>
<span class="lineNum">     340 </span>            :       NS_WARNING(&quot;Could not clear allocated buffer&quot;);
<span class="lineNum">     341 </span><span class="lineNoCov">          0 :       mAborted = true;</span>
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :       return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">     343 </span>            :     }
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span><span class="lineNoCov">          0 :     target = gfxPlatform::CreateDrawTargetForData(</span>
<span class="lineNum">     346 </span><span class="lineNoCov">          0 :                             mLockedSurface-&gt;GetData(),</span>
<span class="lineNum">     347 </span><span class="lineNoCov">          0 :                             mFrameRect.Size(),</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :                             mLockedSurface-&gt;Stride(),</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :                             mFormat);</span>
<span class="lineNum">     350 </span>            :   } else {
<span class="lineNum">     351 </span>            :     // We can't use data surfaces for content, so we'll create an offscreen
<span class="lineNum">     352 </span>            :     // surface instead.  This means if someone later calls RawAccessRef(), we
<span class="lineNum">     353 </span>            :     // may have to do an expensive readback, but we warned callers about that in
<span class="lineNum">     354 </span>            :     // the documentation for this method.
<span class="lineNum">     355 </span>            :     MOZ_ASSERT(!mOptSurface, &quot;Called imgFrame::InitWithDrawable() twice?&quot;);
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineCov">          1 :     if (gfxPlatform::GetPlatform()-&gt;SupportsAzureContentForType(aBackend)) {</span>
<span class="lineNum">     358 </span><span class="lineCov">          1 :       target = gfxPlatform::GetPlatform()-&gt;</span>
<span class="lineNum">     359 </span><span class="lineCov">          1 :         CreateDrawTargetForBackend(aBackend, mFrameRect.Size(), mFormat);</span>
<span class="lineNum">     360 </span>            :     } else {
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :       target = gfxPlatform::GetPlatform()-&gt;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :         CreateOffscreenContentDrawTarget(mFrameRect.Size(), mFormat);</span>
<span class="lineNum">     363 </span>            :     }
<span class="lineNum">     364 </span>            :   }
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span><span class="lineCov">          1 :   if (!target || !target-&gt;IsValid()) {</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :     mAborted = true;</span>
<span class="lineNum">     368 </span><span class="lineNoCov">          0 :     return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">     369 </span>            :   }
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            :   // Draw using the drawable the caller provided.
<span class="lineNum">     372 </span><span class="lineCov">          1 :   RefPtr&lt;gfxContext&gt; ctx = gfxContext::CreateOrNull(target);</span>
<span class="lineNum">     373 </span>            :   MOZ_ASSERT(ctx);  // Already checked the draw target above.
<span class="lineNum">     374 </span><span class="lineCov">          1 :   gfxUtils::DrawPixelSnapped(ctx, aDrawable, mFrameRect.Size(),</span>
<span class="lineNum">     375 </span><span class="lineCov">          1 :                              ImageRegion::Create(ThebesRect(mFrameRect)),</span>
<span class="lineNum">     376 </span><span class="lineCov">          1 :                              mFormat, aSamplingFilter, aImageFlags);</span>
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineCov">          1 :   if (canUseDataSurface &amp;&amp; !mLockedSurface) {</span>
<span class="lineNum">     379 </span>            :     NS_WARNING(&quot;Failed to create VolatileDataSourceSurface&quot;);
<span class="lineNum">     380 </span><span class="lineNoCov">          0 :     mAborted = true;</span>
<span class="lineNum">     381 </span><span class="lineNoCov">          0 :     return NS_ERROR_OUT_OF_MEMORY;</span>
<span class="lineNum">     382 </span>            :   }
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span><span class="lineCov">          1 :   if (!canUseDataSurface) {</span>
<span class="lineNum">     385 </span>            :     // We used an offscreen surface, which is an &quot;optimized&quot; surface from
<span class="lineNum">     386 </span>            :     // imgFrame's perspective.
<span class="lineNum">     387 </span><span class="lineCov">          1 :     mOptSurface = target-&gt;Snapshot();</span>
<span class="lineNum">     388 </span>            :   } else {
<span class="lineNum">     389 </span><span class="lineNoCov">          0 :     FinalizeSurface();</span>
<span class="lineNum">     390 </span>            :   }
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            :   // If we reach this point, we should regard ourselves as complete.
<span class="lineNum">     393 </span><span class="lineCov">          1 :   mDecoded = GetRect();</span>
<span class="lineNum">     394 </span><span class="lineCov">          1 :   mFinished = true;</span>
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            : #ifdef DEBUG
<span class="lineNum">     397 </span>            :   MonitorAutoLock lock(mMonitor);
<span class="lineNum">     398 </span>            :   MOZ_ASSERT(AreAllPixelsWritten());
<span class="lineNum">     399 </span>            : #endif
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">     402 </span>            : }
<a name="403"><span class="lineNum">     403 </span>            : </a>
<span class="lineNum">     404 </span>            : nsresult
<span class="lineNum">     405 </span><span class="lineCov">          1 : imgFrame::Optimize(DrawTarget* aTarget)</span>
<span class="lineNum">     406 </span>            : {
<span class="lineNum">     407 </span>            :   MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">     408 </span><span class="lineCov">          1 :   mMonitor.AssertCurrentThreadOwns();</span>
<span class="lineNum">     409 </span>            :   
<span class="lineNum">     410 </span><span class="lineCov">          1 :   if (mLockCount &gt; 0 || !mOptimizable) {</span>
<span class="lineNum">     411 </span>            :     // Don't optimize right now.
<span class="lineNum">     412 </span>            :     return NS_OK;
<span class="lineNum">     413 </span>            :   }
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            :   // Check whether image optimization is disabled -- not thread safe!
<span class="lineNum">     416 </span>            :   static bool gDisableOptimize = false;
<span class="lineNum">     417 </span>            :   static bool hasCheckedOptimize = false;
<span class="lineNum">     418 </span><span class="lineCov">          1 :   if (!hasCheckedOptimize) {</span>
<span class="lineNum">     419 </span><span class="lineCov">          1 :     if (PR_GetEnv(&quot;MOZ_DISABLE_IMAGE_OPTIMIZE&quot;)) {</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :       gDisableOptimize = true;</span>
<span class="lineNum">     421 </span>            :     }
<span class="lineNum">     422 </span><span class="lineCov">          1 :     hasCheckedOptimize = true;</span>
<span class="lineNum">     423 </span>            :   }
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :   // Don't optimize during shutdown because gfxPlatform may not be available.
<span class="lineNum">     426 </span><span class="lineCov">          1 :   if (ShutdownTracker::ShutdownHasStarted()) {</span>
<span class="lineNum">     427 </span>            :     return NS_OK;
<span class="lineNum">     428 </span>            :   }
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span><span class="lineCov">          1 :   if (gDisableOptimize) {</span>
<span class="lineNum">     431 </span>            :     return NS_OK;
<span class="lineNum">     432 </span>            :   }
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineCov">          1 :   if (mPalettedImageData || mOptSurface) {</span>
<span class="lineNum">     435 </span>            :     return NS_OK;
<span class="lineNum">     436 </span>            :   }
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            :   // XXX(seth): It's currently unclear if there's any reason why we can't
<span class="lineNum">     439 </span>            :   // optimize non-premult surfaces. We should look into removing this.
<span class="lineNum">     440 </span><span class="lineCov">          1 :   if (mNonPremult) {</span>
<span class="lineNum">     441 </span>            :     return NS_OK;
<span class="lineNum">     442 </span>            :   }
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineCov">          1 :   mOptSurface = gfxPlatform::GetPlatform()</span>
<span class="lineNum">     445 </span><span class="lineCov">          1 :     -&gt;ScreenReferenceDrawTarget()-&gt;OptimizeSourceSurface(mLockedSurface);</span>
<span class="lineNum">     446 </span><span class="lineCov">          1 :   if (mOptSurface == mLockedSurface) {</span>
<span class="lineNum">     447 </span><span class="lineCov">          1 :     mOptSurface = nullptr;</span>
<span class="lineNum">     448 </span>            :   }
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span><span class="lineCov">          1 :   if (mOptSurface) {</span>
<span class="lineNum">     451 </span>            :     // There's no reason to keep our original surface around if we have an
<span class="lineNum">     452 </span>            :     // optimized surface. Release our reference to it. This will leave
<span class="lineNum">     453 </span>            :     // |mLockedSurface| as the only thing keeping it alive, so it'll get freed
<span class="lineNum">     454 </span>            :     // below.
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :     mRawSurface = nullptr;</span>
<span class="lineNum">     456 </span>            :   }
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            :   // Release all strong references to the surface's memory. If the underlying
<span class="lineNum">     459 </span>            :   // surface is volatile, this will allow the operating system to free the
<span class="lineNum">     460 </span>            :   // memory if it needs to.
<span class="lineNum">     461 </span><span class="lineCov">          1 :   mLockedSurface = nullptr;</span>
<span class="lineNum">     462 </span><span class="lineCov">          1 :   mOptimizable = false;</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">     465 </span>            : }
<a name="466"><span class="lineNum">     466 </span>            : </a>
<span class="lineNum">     467 </span>            : DrawableFrameRef
<span class="lineNum">     468 </span><span class="lineCov">          1 : imgFrame::DrawableRef()</span>
<span class="lineNum">     469 </span>            : {
<span class="lineNum">     470 </span><span class="lineCov">          1 :   return DrawableFrameRef(this);</span>
<span class="lineNum">     471 </span>            : }
<a name="472"><span class="lineNum">     472 </span>            : </a>
<span class="lineNum">     473 </span>            : RawAccessFrameRef
<span class="lineNum">     474 </span><span class="lineCov">          1 : imgFrame::RawAccessRef()</span>
<span class="lineNum">     475 </span>            : {
<span class="lineNum">     476 </span><span class="lineCov">          1 :   return RawAccessFrameRef(this);</span>
<span class="lineNum">     477 </span>            : }
<a name="478"><span class="lineNum">     478 </span>            : </a>
<span class="lineNum">     479 </span>            : void
<span class="lineNum">     480 </span><span class="lineCov">          1 : imgFrame::SetRawAccessOnly()</span>
<span class="lineNum">     481 </span>            : {
<span class="lineNum">     482 </span>            :   AssertImageDataLocked();
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span>            :   // Lock our data and throw away the key.
<span class="lineNum">     485 </span><span class="lineCov">          1 :   LockImageData();</span>
<span class="lineNum">     486 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     487 </span>            : 
<a name="488"><span class="lineNum">     488 </span>            : </a>
<span class="lineNum">     489 </span>            : imgFrame::SurfaceWithFormat
<span class="lineNum">     490 </span><span class="lineCov">          1 : imgFrame::SurfaceForDrawing(bool               aDoPartialDecode,</span>
<span class="lineNum">     491 </span>            :                             bool               aDoTile,
<span class="lineNum">     492 </span>            :                             ImageRegion&amp;       aRegion,
<span class="lineNum">     493 </span>            :                             SourceSurface*     aSurface)
<span class="lineNum">     494 </span>            : {
<span class="lineNum">     495 </span>            :   MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">     496 </span><span class="lineCov">          1 :   mMonitor.AssertCurrentThreadOwns();</span>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span><span class="lineCov">          1 :   if (!aDoPartialDecode) {</span>
<span class="lineNum">     499 </span><span class="lineCov">          1 :     return SurfaceWithFormat(new gfxSurfaceDrawable(aSurface, mImageSize),</span>
<span class="lineNum">     500 </span><span class="lineCov">          1 :                              mFormat);</span>
<span class="lineNum">     501 </span>            :   }
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            :   gfxRect available = gfxRect(mDecoded.x, mDecoded.y, mDecoded.width,
<span class="lineNum">     504 </span><span class="lineCov">          1 :                               mDecoded.height);</span>
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span><span class="lineCov">          1 :   if (aDoTile) {</span>
<span class="lineNum">     507 </span>            :     // Create a temporary surface.
<span class="lineNum">     508 </span>            :     // Give this surface an alpha channel because there are
<span class="lineNum">     509 </span>            :     // transparent pixels in the padding or undecoded area
<span class="lineNum">     510 </span>            :     RefPtr&lt;DrawTarget&gt; target =
<span class="lineNum">     511 </span>            :       gfxPlatform::GetPlatform()-&gt;
<span class="lineNum">     512 </span><span class="lineNoCov">          0 :         CreateOffscreenContentDrawTarget(mImageSize, SurfaceFormat::B8G8R8A8);</span>
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :     if (!target) {</span>
<span class="lineNum">     514 </span>            :       return SurfaceWithFormat();
<span class="lineNum">     515 </span>            :     }
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            :     SurfacePattern pattern(aSurface,
<span class="lineNum">     518 </span>            :                            aRegion.GetExtendMode(),
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :                            Matrix::Translation(mDecoded.x, mDecoded.y));</span>
<span class="lineNum">     520 </span><span class="lineNoCov">          0 :     target-&gt;FillRect(ToRect(aRegion.Intersect(available).Rect()), pattern);</span>
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :     RefPtr&lt;SourceSurface&gt; newsurf = target-&gt;Snapshot();</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :     return SurfaceWithFormat(new gfxSurfaceDrawable(newsurf, mImageSize),</span>
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :                              target-&gt;GetFormat());</span>
<span class="lineNum">     525 </span>            :   }
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            :   // Not tiling, and we have a surface, so we can account for
<span class="lineNum">     528 </span>            :   // a partial decode just by twiddling parameters.
<span class="lineNum">     529 </span><span class="lineCov">          1 :   aRegion = aRegion.Intersect(available);</span>
<span class="lineNum">     530 </span><span class="lineCov">          1 :   IntSize availableSize(mDecoded.width, mDecoded.height);</span>
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span><span class="lineCov">          1 :   return SurfaceWithFormat(new gfxSurfaceDrawable(aSurface, availableSize),</span>
<span class="lineNum">     533 </span><span class="lineCov">          1 :                            mFormat);</span>
<a name="534"><span class="lineNum">     534 </span>            : }</a>
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span><span class="lineCov">          1 : bool imgFrame::Draw(gfxContext* aContext, const ImageRegion&amp; aRegion,</span>
<span class="lineNum">     537 </span>            :                     SamplingFilter aSamplingFilter, uint32_t aImageFlags,
<span class="lineNum">     538 </span>            :                     float aOpacity)
<span class="lineNum">     539 </span>            : {
<span class="lineNum">     540 </span><span class="lineCov">          1 :   PROFILER_LABEL(&quot;imgFrame&quot;, &quot;Draw&quot;,</span>
<span class="lineNum">     541 </span>            :     js::ProfileEntry::Category::GRAPHICS);
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span>            :   MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">     544 </span>            :   NS_ASSERTION(!aRegion.Rect().IsEmpty(), &quot;Drawing empty region!&quot;);
<span class="lineNum">     545 </span>            :   NS_ASSERTION(!aRegion.IsRestricted() ||
<span class="lineNum">     546 </span>            :                !aRegion.Rect().Intersect(aRegion.Restriction()).IsEmpty(),
<span class="lineNum">     547 </span>            :                &quot;We must be allowed to sample *some* source pixels!&quot;);
<span class="lineNum">     548 </span>            :   MOZ_ASSERT(mFrameRect.IsEqualEdges(IntRect(IntPoint(), mImageSize)),
<span class="lineNum">     549 </span>            :              &quot;Directly drawing an image with a non-trivial frame rect!&quot;);
<span class="lineNum">     550 </span>            : 
<span class="lineNum">     551 </span><span class="lineCov">          1 :   if (mPalettedImageData) {</span>
<span class="lineNum">     552 </span>            :     MOZ_ASSERT_UNREACHABLE(&quot;Directly drawing a paletted image!&quot;);
<span class="lineNum">     553 </span>            :     return false;
<span class="lineNum">     554 </span>            :   }
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span>            :   // Possibly convert this image into a GPU texture, this may also cause our
<span class="lineNum">     559 </span>            :   // mLockedSurface to be released and the OS to release the underlying memory.
<span class="lineNum">     560 </span><span class="lineCov">          1 :   Optimize(aContext-&gt;GetDrawTarget());</span>
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span><span class="lineCov">          1 :   bool doPartialDecode = !AreAllPixelsWritten();</span>
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span><span class="lineCov">          1 :   RefPtr&lt;SourceSurface&gt; surf = GetSourceSurfaceInternal();</span>
<span class="lineNum">     565 </span><span class="lineCov">          1 :   if (!surf) {</span>
<span class="lineNum">     566 </span>            :     return false;
<span class="lineNum">     567 </span>            :   }
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span><span class="lineCov">          1 :   gfxRect imageRect(0, 0, mImageSize.width, mImageSize.height);</span>
<span class="lineNum">     570 </span><span class="lineCov">          1 :   bool doTile = !imageRect.Contains(aRegion.Rect()) &amp;&amp;</span>
<span class="lineNum">     571 </span><span class="lineCov">          1 :                 !(aImageFlags &amp; imgIContainer::FLAG_CLAMP);</span>
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span><span class="lineCov">          1 :   ImageRegion region(aRegion);</span>
<span class="lineNum">     574 </span>            :   SurfaceWithFormat surfaceResult =
<span class="lineNum">     575 </span><span class="lineCov">          1 :     SurfaceForDrawing(doPartialDecode, doTile, region, surf);</span>
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineCov">          1 :   if (surfaceResult.IsValid()) {</span>
<span class="lineNum">     578 </span>            :     gfxUtils::DrawPixelSnapped(aContext, surfaceResult.mDrawable,
<span class="lineNum">     579 </span>            :                                imageRect.Size(), region, surfaceResult.mFormat,
<span class="lineNum">     580 </span><span class="lineCov">          1 :                                aSamplingFilter, aImageFlags, aOpacity);</span>
<span class="lineNum">     581 </span>            :   }
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            :   // Image got put into a painted layer, it will not be shared with another
<span class="lineNum">     584 </span>            :   // process.
<span class="lineNum">     585 </span><span class="lineCov">          1 :   MarkSurfaceShared(surf);</span>
<span class="lineNum">     586 </span><span class="lineCov">          1 :   return true;</span>
<span class="lineNum">     587 </span>            : }
<a name="588"><span class="lineNum">     588 </span>            : </a>
<span class="lineNum">     589 </span>            : nsresult
<span class="lineNum">     590 </span><span class="lineCov">          1 : imgFrame::ImageUpdated(const nsIntRect&amp; aUpdateRect)</span>
<span class="lineNum">     591 </span>            : {
<span class="lineNum">     592 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     593 </span><span class="lineCov">          1 :   return ImageUpdatedInternal(aUpdateRect);</span>
<span class="lineNum">     594 </span>            : }
<a name="595"><span class="lineNum">     595 </span>            : </a>
<span class="lineNum">     596 </span>            : nsresult
<span class="lineNum">     597 </span><span class="lineCov">          1 : imgFrame::ImageUpdatedInternal(const nsIntRect&amp; aUpdateRect)</span>
<span class="lineNum">     598 </span>            : {
<span class="lineNum">     599 </span><span class="lineCov">          1 :   mMonitor.AssertCurrentThreadOwns();</span>
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineCov">          1 :   mDecoded.UnionRect(mDecoded, aUpdateRect);</span>
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span>            :   // Clamp to the frame rect to ensure that decoder bugs don't result in a
<span class="lineNum">     604 </span>            :   // decoded rect that extends outside the bounds of the frame rect.
<span class="lineNum">     605 </span><span class="lineCov">          1 :   mDecoded.IntersectRect(mDecoded, mFrameRect);</span>
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">     608 </span>            : }
<a name="609"><span class="lineNum">     609 </span>            : </a>
<span class="lineNum">     610 </span>            : void
<span class="lineNum">     611 </span><span class="lineCov">          1 : imgFrame::Finish(Opacity aFrameOpacity /* = Opacity::SOME_TRANSPARENCY */,</span>
<span class="lineNum">     612 </span>            :                  DisposalMethod aDisposalMethod /* = DisposalMethod::KEEP */,
<span class="lineNum">     613 </span>            :                  FrameTimeout aTimeout
<span class="lineNum">     614 </span>            :                    /* = FrameTimeout::FromRawMilliseconds(0) */,
<span class="lineNum">     615 </span>            :                  BlendMethod aBlendMethod /* = BlendMethod::OVER */,
<span class="lineNum">     616 </span>            :                  const Maybe&lt;IntRect&gt;&amp; aBlendRect /* = Nothing() */,
<span class="lineNum">     617 </span>            :                  bool aFinalize /* = true */)
<span class="lineNum">     618 </span>            : {
<span class="lineNum">     619 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     620 </span>            :   MOZ_ASSERT(mLockCount &gt; 0, &quot;Image data should be locked&quot;);
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span><span class="lineCov">          1 :   mDisposalMethod = aDisposalMethod;</span>
<span class="lineNum">     623 </span><span class="lineCov">          1 :   mTimeout = aTimeout;</span>
<span class="lineNum">     624 </span><span class="lineCov">          1 :   mBlendMethod = aBlendMethod;</span>
<span class="lineNum">     625 </span><span class="lineCov">          1 :   mBlendRect = aBlendRect;</span>
<span class="lineNum">     626 </span><span class="lineCov">          1 :   ImageUpdatedInternal(GetRect());</span>
<span class="lineNum">     627 </span>            : 
<span class="lineNum">     628 </span><span class="lineCov">          1 :   if (aFinalize) {</span>
<span class="lineNum">     629 </span><span class="lineCov">          1 :     FinalizeSurfaceInternal();</span>
<span class="lineNum">     630 </span>            :   }
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span><span class="lineCov">          1 :   mFinished = true;</span>
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :   // The image is now complete, wake up anyone who's waiting.
<span class="lineNum">     635 </span><span class="lineCov">          1 :   mMonitor.NotifyAll();</span>
<span class="lineNum">     636 </span><span class="lineCov">          1 : }</span>
<a name="637"><span class="lineNum">     637 </span>            : </a>
<span class="lineNum">     638 </span>            : uint32_t
<span class="lineNum">     639 </span><span class="lineCov">          1 : imgFrame::GetImageBytesPerRow() const</span>
<span class="lineNum">     640 </span>            : {
<span class="lineNum">     641 </span><span class="lineCov">          1 :   mMonitor.AssertCurrentThreadOwns();</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span><span class="lineCov">          1 :   if (mRawSurface) {</span>
<span class="lineNum">     644 </span><span class="lineCov">          1 :     return mFrameRect.width * BytesPerPixel(mFormat);</span>
<span class="lineNum">     645 </span>            :   }
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineCov">          1 :   if (mPaletteDepth) {</span>
<span class="lineNum">     648 </span><span class="lineCov">          1 :     return mFrameRect.width;</span>
<span class="lineNum">     649 </span>            :   }
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            :   return 0;
<span class="lineNum">     652 </span>            : }
<a name="653"><span class="lineNum">     653 </span>            : </a>
<span class="lineNum">     654 </span>            : uint32_t
<span class="lineNum">     655 </span><span class="lineCov">          1 : imgFrame::GetImageDataLength() const</span>
<span class="lineNum">     656 </span>            : {
<span class="lineNum">     657 </span><span class="lineCov">          1 :   return GetImageBytesPerRow() * mFrameRect.height;</span>
<span class="lineNum">     658 </span>            : }
<a name="659"><span class="lineNum">     659 </span>            : </a>
<span class="lineNum">     660 </span>            : void
<span class="lineNum">     661 </span><span class="lineCov">          1 : imgFrame::GetImageData(uint8_t** aData, uint32_t* aLength) const</span>
<span class="lineNum">     662 </span>            : {
<span class="lineNum">     663 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     664 </span><span class="lineCov">          1 :   GetImageDataInternal(aData, aLength);</span>
<span class="lineNum">     665 </span><span class="lineCov">          1 : }</span>
<a name="666"><span class="lineNum">     666 </span>            : </a>
<span class="lineNum">     667 </span>            : void
<span class="lineNum">     668 </span><span class="lineCov">          1 : imgFrame::GetImageDataInternal(uint8_t** aData, uint32_t* aLength) const</span>
<span class="lineNum">     669 </span>            : {
<span class="lineNum">     670 </span><span class="lineCov">          1 :   mMonitor.AssertCurrentThreadOwns();</span>
<span class="lineNum">     671 </span>            :   MOZ_ASSERT(mLockCount &gt; 0, &quot;Image data should be locked&quot;);
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span><span class="lineCov">          1 :   if (mLockedSurface) {</span>
<span class="lineNum">     674 </span>            :     // TODO: This is okay for now because we only realloc shared surfaces on
<span class="lineNum">     675 </span>            :     // the main thread after decoding has finished, but if animations want to
<span class="lineNum">     676 </span>            :     // read frame data off the main thread, we will need to reconsider this.
<span class="lineNum">     677 </span><span class="lineCov">          1 :     *aData = mLockedSurface-&gt;GetData();</span>
<span class="lineNum">     678 </span>            :     MOZ_ASSERT(*aData,
<span class="lineNum">     679 </span>            :       &quot;mLockedSurface is non-null, but GetData is null in GetImageData&quot;);
<span class="lineNum">     680 </span><span class="lineCov">          1 :   } else if (mPalettedImageData) {</span>
<span class="lineNum">     681 </span><span class="lineCov">          1 :     *aData = mPalettedImageData + PaletteDataLength();</span>
<span class="lineNum">     682 </span>            :     MOZ_ASSERT(*aData,
<span class="lineNum">     683 </span>            :       &quot;mPalettedImageData is non-null, but result is null in GetImageData&quot;);
<span class="lineNum">     684 </span>            :   } else {
<span class="lineNum">     685 </span>            :     MOZ_ASSERT(false,
<span class="lineNum">     686 </span>            :       &quot;Have neither mLockedSurface nor mPalettedImageData in GetImageData&quot;);
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :     *aData = nullptr;</span>
<span class="lineNum">     688 </span>            :   }
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span><span class="lineCov">          1 :   *aLength = GetImageDataLength();</span>
<span class="lineNum">     691 </span><span class="lineCov">          1 : }</span>
<a name="692"><span class="lineNum">     692 </span>            : </a>
<span class="lineNum">     693 </span>            : uint8_t*
<span class="lineNum">     694 </span><span class="lineNoCov">          0 : imgFrame::GetImageData() const</span>
<span class="lineNum">     695 </span>            : {
<span class="lineNum">     696 </span>            :   uint8_t* data;
<span class="lineNum">     697 </span>            :   uint32_t length;
<span class="lineNum">     698 </span><span class="lineNoCov">          0 :   GetImageData(&amp;data, &amp;length);</span>
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :   return data;</span>
<span class="lineNum">     700 </span>            : }
<a name="701"><span class="lineNum">     701 </span>            : </a>
<span class="lineNum">     702 </span>            : bool
<span class="lineNum">     703 </span><span class="lineCov">          1 : imgFrame::GetIsPaletted() const</span>
<span class="lineNum">     704 </span>            : {
<span class="lineNum">     705 </span><span class="lineCov">          1 :   return mPalettedImageData != nullptr;</span>
<span class="lineNum">     706 </span>            : }
<a name="707"><span class="lineNum">     707 </span>            : </a>
<span class="lineNum">     708 </span>            : void
<span class="lineNum">     709 </span><span class="lineCov">          1 : imgFrame::GetPaletteData(uint32_t** aPalette, uint32_t* length) const</span>
<span class="lineNum">     710 </span>            : {
<span class="lineNum">     711 </span>            :   AssertImageDataLocked();
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span><span class="lineCov">          1 :   if (!mPalettedImageData) {</span>
<span class="lineNum">     714 </span><span class="lineCov">          1 :     *aPalette = nullptr;</span>
<span class="lineNum">     715 </span><span class="lineCov">          1 :     *length = 0;</span>
<span class="lineNum">     716 </span>            :   } else {
<span class="lineNum">     717 </span><span class="lineCov">          1 :     *aPalette = (uint32_t*) mPalettedImageData;</span>
<span class="lineNum">     718 </span><span class="lineCov">          1 :     *length = PaletteDataLength();</span>
<span class="lineNum">     719 </span>            :   }
<span class="lineNum">     720 </span><span class="lineCov">          1 : }</span>
<a name="721"><span class="lineNum">     721 </span>            : </a>
<span class="lineNum">     722 </span>            : uint32_t*
<span class="lineNum">     723 </span><span class="lineNoCov">          0 : imgFrame::GetPaletteData() const</span>
<span class="lineNum">     724 </span>            : {
<span class="lineNum">     725 </span>            :   uint32_t* data;
<span class="lineNum">     726 </span>            :   uint32_t length;
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :   GetPaletteData(&amp;data, &amp;length);</span>
<span class="lineNum">     728 </span><span class="lineNoCov">          0 :   return data;</span>
<span class="lineNum">     729 </span>            : }
<a name="730"><span class="lineNum">     730 </span>            : </a>
<span class="lineNum">     731 </span>            : nsresult
<span class="lineNum">     732 </span><span class="lineCov">          1 : imgFrame::LockImageData()</span>
<span class="lineNum">     733 </span>            : {
<span class="lineNum">     734 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            :   MOZ_ASSERT(mLockCount &gt;= 0, &quot;Unbalanced locks and unlocks&quot;);
<span class="lineNum">     737 </span><span class="lineCov">          1 :   if (mLockCount &lt; 0) {</span>
<span class="lineNum">     738 </span>            :     return NS_ERROR_FAILURE;
<span class="lineNum">     739 </span>            :   }
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span><span class="lineCov">          1 :   mLockCount++;</span>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            :   // If we are not the first lock, there's nothing to do.
<span class="lineNum">     744 </span><span class="lineCov">          1 :   if (mLockCount != 1) {</span>
<span class="lineNum">     745 </span>            :     return NS_OK;
<span class="lineNum">     746 </span>            :   }
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            :   // If we're the first lock, but have the locked surface, we're OK.
<span class="lineNum">     749 </span><span class="lineCov">          1 :   if (mLockedSurface) {</span>
<span class="lineNum">     750 </span>            :     return NS_OK;
<span class="lineNum">     751 </span>            :   }
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span>            :   // Paletted images don't have surfaces, so there's nothing to do.
<span class="lineNum">     754 </span><span class="lineCov">          1 :   if (mPalettedImageData) {</span>
<span class="lineNum">     755 </span>            :     return NS_OK;
<span class="lineNum">     756 </span>            :   }
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span>            :   MOZ_ASSERT_UNREACHABLE(&quot;It's illegal to re-lock an optimized imgFrame&quot;);
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :   return NS_ERROR_FAILURE;</span>
<span class="lineNum">     760 </span>            : }
<a name="761"><span class="lineNum">     761 </span>            : </a>
<span class="lineNum">     762 </span>            : void
<span class="lineNum">     763 </span><span class="lineNoCov">          0 : imgFrame::AssertImageDataLocked() const</span>
<span class="lineNum">     764 </span>            : {
<span class="lineNum">     765 </span>            : #ifdef DEBUG
<span class="lineNum">     766 </span>            :   MonitorAutoLock lock(mMonitor);
<span class="lineNum">     767 </span>            :   MOZ_ASSERT(mLockCount &gt; 0, &quot;Image data should be locked&quot;);
<span class="lineNum">     768 </span>            : #endif
<span class="lineNum">     769 </span><span class="lineNoCov">          0 : }</span>
<a name="770"><span class="lineNum">     770 </span>            : </a>
<span class="lineNum">     771 </span>            : nsresult
<span class="lineNum">     772 </span><span class="lineCov">          1 : imgFrame::UnlockImageData()</span>
<span class="lineNum">     773 </span>            : {
<span class="lineNum">     774 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span>            :   MOZ_ASSERT(mLockCount &gt; 0, &quot;Unlocking an unlocked image!&quot;);
<span class="lineNum">     777 </span><span class="lineCov">          1 :   if (mLockCount &lt;= 0) {</span>
<span class="lineNum">     778 </span>            :     return NS_ERROR_FAILURE;
<span class="lineNum">     779 </span>            :   }
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            :   MOZ_ASSERT(mLockCount &gt; 1 || mFinished || mAborted,
<span class="lineNum">     782 </span>            :              &quot;Should have Finish()'d or aborted before unlocking&quot;);
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span><span class="lineCov">          1 :   mLockCount--;</span>
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span><span class="lineCov">          1 :   return NS_OK;</span>
<span class="lineNum">     787 </span>            : }
<a name="788"><span class="lineNum">     788 </span>            : </a>
<span class="lineNum">     789 </span>            : void
<span class="lineNum">     790 </span><span class="lineCov">          1 : imgFrame::SetOptimizable()</span>
<span class="lineNum">     791 </span>            : {
<span class="lineNum">     792 </span>            :   AssertImageDataLocked();
<span class="lineNum">     793 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     794 </span><span class="lineCov">          1 :   mOptimizable = true;</span>
<span class="lineNum">     795 </span><span class="lineCov">          1 : }</span>
<a name="796"><span class="lineNum">     796 </span>            : </a>
<span class="lineNum">     797 </span>            : void
<span class="lineNum">     798 </span><span class="lineNoCov">          0 : imgFrame::FinalizeSurface()</span>
<span class="lineNum">     799 </span>            : {
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     801 </span><span class="lineNoCov">          0 :   FinalizeSurfaceInternal();</span>
<span class="lineNum">     802 </span><span class="lineNoCov">          0 : }</span>
<a name="803"><span class="lineNum">     803 </span>            : </a>
<span class="lineNum">     804 </span>            : void
<span class="lineNum">     805 </span><span class="lineCov">          1 : imgFrame::FinalizeSurfaceInternal()</span>
<span class="lineNum">     806 </span>            : {
<span class="lineNum">     807 </span><span class="lineCov">          1 :   mMonitor.AssertCurrentThreadOwns();</span>
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :   // Not all images will have mRawSurface to finalize (i.e. paletted images).
<span class="lineNum">     810 </span><span class="lineCov">          1 :   if (!mRawSurface || mRawSurface-&gt;GetType() != SurfaceType::DATA_SHARED) {</span>
<span class="lineNum">     811 </span><span class="lineCov">          1 :     return;</span>
<span class="lineNum">     812 </span>            :   }
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :   auto sharedSurf = static_cast&lt;SourceSurfaceSharedData*&gt;(mRawSurface.get());</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :   sharedSurf-&gt;Finalize();</span>
<span class="lineNum">     816 </span>            : }
<a name="817"><span class="lineNum">     817 </span>            : </a>
<span class="lineNum">     818 </span>            : already_AddRefed&lt;SourceSurface&gt;
<span class="lineNum">     819 </span><span class="lineCov">          1 : imgFrame::GetSourceSurface()</span>
<span class="lineNum">     820 </span>            : {
<span class="lineNum">     821 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     822 </span><span class="lineCov">          1 :   return GetSourceSurfaceInternal();</span>
<span class="lineNum">     823 </span>            : }
<a name="824"><span class="lineNum">     824 </span>            : </a>
<span class="lineNum">     825 </span>            : already_AddRefed&lt;SourceSurface&gt;
<span class="lineNum">     826 </span><span class="lineCov">          1 : imgFrame::GetSourceSurfaceInternal()</span>
<span class="lineNum">     827 </span>            : {
<span class="lineNum">     828 </span><span class="lineCov">          1 :   mMonitor.AssertCurrentThreadOwns();</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineCov">          1 :   if (mOptSurface) {</span>
<span class="lineNum">     831 </span><span class="lineCov">          1 :     if (mOptSurface-&gt;IsValid()) {</span>
<span class="lineNum">     832 </span><span class="lineCov">          1 :       RefPtr&lt;SourceSurface&gt; surf(mOptSurface);</span>
<span class="lineNum">     833 </span><span class="lineCov">          1 :       return surf.forget();</span>
<span class="lineNum">     834 </span>            :     } else {
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :       mOptSurface = nullptr;</span>
<span class="lineNum">     836 </span>            :     }
<span class="lineNum">     837 </span>            :   }
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span><span class="lineCov">          1 :   if (mLockedSurface) {</span>
<span class="lineNum">     840 </span><span class="lineCov">          1 :     RefPtr&lt;SourceSurface&gt; surf(mLockedSurface);</span>
<span class="lineNum">     841 </span><span class="lineCov">          1 :     return surf.forget();</span>
<span class="lineNum">     842 </span>            :   }
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span><span class="lineCov">          1 :   if (!mRawSurface) {</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :     return nullptr;</span>
<span class="lineNum">     846 </span>            :   }
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span><span class="lineCov">          1 :   return CreateLockedSurface(mRawSurface, mFrameRect.Size(), mFormat);</span>
<span class="lineNum">     849 </span>            : }
<a name="850"><span class="lineNum">     850 </span>            : </a>
<span class="lineNum">     851 </span>            : AnimationData
<span class="lineNum">     852 </span><span class="lineCov">          1 : imgFrame::GetAnimationData() const</span>
<span class="lineNum">     853 </span>            : {
<span class="lineNum">     854 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     855 </span>            :   MOZ_ASSERT(mLockCount &gt; 0, &quot;Image data should be locked&quot;);
<span class="lineNum">     856 </span>            : 
<span class="lineNum">     857 </span>            :   uint8_t* data;
<span class="lineNum">     858 </span><span class="lineCov">          1 :   if (mPalettedImageData) {</span>
<span class="lineNum">     859 </span><span class="lineCov">          1 :     data = mPalettedImageData;</span>
<span class="lineNum">     860 </span>            :   } else {
<span class="lineNum">     861 </span>            :     uint32_t length;
<span class="lineNum">     862 </span><span class="lineCov">          1 :     GetImageDataInternal(&amp;data, &amp;length);</span>
<span class="lineNum">     863 </span>            :   }
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span><span class="lineCov">          1 :   bool hasAlpha = mFormat == SurfaceFormat::B8G8R8A8;</span>
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span>            :   return AnimationData(data, PaletteDataLength(), mTimeout, GetRect(),
<span class="lineNum">     868 </span><span class="lineCov">          1 :                        mBlendMethod, mBlendRect, mDisposalMethod, hasAlpha);</span>
<span class="lineNum">     869 </span>            : }
<a name="870"><span class="lineNum">     870 </span>            : </a>
<span class="lineNum">     871 </span>            : void
<span class="lineNum">     872 </span><span class="lineCov">          1 : imgFrame::Abort()</span>
<span class="lineNum">     873 </span>            : {
<span class="lineNum">     874 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span><span class="lineCov">          1 :   mAborted = true;</span>
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            :   // Wake up anyone who's waiting.
<span class="lineNum">     879 </span><span class="lineCov">          1 :   mMonitor.NotifyAll();</span>
<span class="lineNum">     880 </span><span class="lineCov">          1 : }</span>
<a name="881"><span class="lineNum">     881 </span>            : </a>
<span class="lineNum">     882 </span>            : bool
<span class="lineNum">     883 </span><span class="lineCov">          1 : imgFrame::IsAborted() const</span>
<span class="lineNum">     884 </span>            : {
<span class="lineNum">     885 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     886 </span><span class="lineCov">          1 :   return mAborted;</span>
<span class="lineNum">     887 </span>            : }
<a name="888"><span class="lineNum">     888 </span>            : </a>
<span class="lineNum">     889 </span>            : bool
<span class="lineNum">     890 </span><span class="lineCov">          1 : imgFrame::IsFinished() const</span>
<span class="lineNum">     891 </span>            : {
<span class="lineNum">     892 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     893 </span><span class="lineCov">          1 :   return mFinished;</span>
<span class="lineNum">     894 </span>            : }
<a name="895"><span class="lineNum">     895 </span>            : </a>
<span class="lineNum">     896 </span>            : void
<span class="lineNum">     897 </span><span class="lineCov">          1 : imgFrame::WaitUntilFinished() const</span>
<span class="lineNum">     898 </span>            : {
<span class="lineNum">     899 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     900 </span>            : 
<span class="lineNum">     901 </span>            :   while (true) {
<span class="lineNum">     902 </span>            :     // Return if we're aborted or complete.
<span class="lineNum">     903 </span><span class="lineCov">          1 :     if (mAborted || mFinished) {</span>
<span class="lineNum">     904 </span><span class="lineCov">          1 :       return;</span>
<span class="lineNum">     905 </span>            :     }
<span class="lineNum">     906 </span>            : 
<span class="lineNum">     907 </span>            :     // Not complete yet, so we'll have to wait.
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :     mMonitor.Wait();</span>
<span class="lineNum">     909 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">     910 </span>            : }
<a name="911"><span class="lineNum">     911 </span>            : </a>
<span class="lineNum">     912 </span>            : bool
<span class="lineNum">     913 </span><span class="lineCov">          1 : imgFrame::AreAllPixelsWritten() const</span>
<span class="lineNum">     914 </span>            : {
<span class="lineNum">     915 </span><span class="lineCov">          1 :   mMonitor.AssertCurrentThreadOwns();</span>
<span class="lineNum">     916 </span><span class="lineCov">          1 :   return mDecoded.IsEqualInterior(mFrameRect);</span>
<a name="917"><span class="lineNum">     917 </span>            : }</a>
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span><span class="lineCov">          1 : bool imgFrame::GetCompositingFailed() const</span>
<span class="lineNum">     920 </span>            : {
<span class="lineNum">     921 </span>            :   MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">     922 </span><span class="lineCov">          1 :   return mCompositingFailed;</span>
<span class="lineNum">     923 </span>            : }
<a name="924"><span class="lineNum">     924 </span>            : </a>
<span class="lineNum">     925 </span>            : void
<span class="lineNum">     926 </span><span class="lineCov">          1 : imgFrame::SetCompositingFailed(bool val)</span>
<span class="lineNum">     927 </span>            : {
<span class="lineNum">     928 </span>            :   MOZ_ASSERT(NS_IsMainThread());
<span class="lineNum">     929 </span><span class="lineCov">          1 :   mCompositingFailed = val;</span>
<span class="lineNum">     930 </span><span class="lineCov">          1 : }</span>
<a name="931"><span class="lineNum">     931 </span>            : </a>
<span class="lineNum">     932 </span>            : void
<span class="lineNum">     933 </span><span class="lineCov">          1 : imgFrame::AddSizeOfExcludingThis(MallocSizeOf aMallocSizeOf,</span>
<span class="lineNum">     934 </span>            :                                  size_t&amp; aHeapSizeOut,
<span class="lineNum">     935 </span>            :                                  size_t&amp; aNonHeapSizeOut,
<span class="lineNum">     936 </span>            :                                  size_t&amp; aSharedHandlesOut) const
<span class="lineNum">     937 </span>            : {
<span class="lineNum">     938 </span><span class="lineCov">          1 :   MonitorAutoLock lock(mMonitor);</span>
<span class="lineNum">     939 </span>            : 
<span class="lineNum">     940 </span><span class="lineCov">          1 :   if (mPalettedImageData) {</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :     aHeapSizeOut += aMallocSizeOf(mPalettedImageData);</span>
<span class="lineNum">     942 </span>            :   }
<span class="lineNum">     943 </span><span class="lineCov">          1 :   if (mLockedSurface) {</span>
<span class="lineNum">     944 </span><span class="lineCov">          1 :     aHeapSizeOut += aMallocSizeOf(mLockedSurface);</span>
<span class="lineNum">     945 </span>            :   }
<span class="lineNum">     946 </span><span class="lineCov">          1 :   if (mOptSurface) {</span>
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :     aHeapSizeOut += aMallocSizeOf(mOptSurface);</span>
<span class="lineNum">     948 </span>            :   }
<span class="lineNum">     949 </span><span class="lineCov">          1 :   if (mRawSurface) {</span>
<span class="lineNum">     950 </span><span class="lineCov">          1 :     aHeapSizeOut += aMallocSizeOf(mRawSurface);</span>
<span class="lineNum">     951 </span><span class="lineCov">          1 :     mRawSurface-&gt;AddSizeOfExcludingThis(aMallocSizeOf, aHeapSizeOut,</span>
<span class="lineNum">     952 </span><span class="lineCov">          1 :                                         aNonHeapSizeOut);</span>
<span class="lineNum">     953 </span>            : 
<span class="lineNum">     954 </span><span class="lineCov">          1 :     if (mRawSurface-&gt;GetType() == SurfaceType::DATA_SHARED) {</span>
<span class="lineNum">     955 </span>            :       auto sharedSurface =
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :         static_cast&lt;SourceSurfaceSharedData*&gt;(mRawSurface.get());</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :       if (sharedSurface-&gt;CanShare()) {</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :         ++aSharedHandlesOut;</span>
<span class="lineNum">     959 </span>            :       }
<span class="lineNum">     960 </span>            :     }
<span class="lineNum">     961 </span><span class="lineCov">          1 :   }</span>
<span class="lineNum">     962 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            : } // namespace image
<span class="lineNum">     965 </span>            : } // namespace mozilla
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13-2-g25f5d38</a></td></tr>
  </table>
  <br>

</body>
</html>
